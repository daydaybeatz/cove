<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ASCII Survivors</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --fg: #f7f7f7;
      --muted: #91a0b8;
      --panel: #111522;
      --accent: #6ae3ff;
      --hp: #ff5c5c;
      --xp: #89ff8f;
      --player: #73f0ff;
      --enemy: #ff6f7d;
      --bullet: #ffd166;
      --pickup: #6cff8d;
      --gem: #7dff95;
      --aura: #d4ff7a;
      --bat: #bda6ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: var(--bg);
      color: var(--fg);
      touch-action: none;
      overscroll-behavior: none;
      user-select: none;
    }
    .app {
      min-height: 100svh;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 8px;
      padding: max(10px, env(safe-area-inset-top)) 10px max(14px, env(safe-area-inset-bottom));
    }
    .hud {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      font-size: 14px;
    }
    .bar {
      height: 10px;
      background: #1d2436;
      border-radius: 999px;
      overflow: hidden;
      margin-top: 4px;
    }
    .fill { height: 100%; }
    .hp-fill { background: var(--hp); }
    .xp-fill { background: var(--xp); }
    .screen-wrap {
      position: relative;
      min-height: 56vh;
    }
    #screen {
      margin: 0;
      background: #080b12;
      border: 1px solid #1e2a44;
      border-radius: 10px;
      font-size: clamp(14px, 2.6vw, 20px);
      line-height: 1;
      letter-spacing: 0.02em;
      padding: 8px;
      white-space: pre;
      overflow: hidden;
      color: #dbe8ff;
      min-height: 56vh;
    }
    #entityLayer {
      position: absolute;
      inset: 0;
      padding: 8px;
      pointer-events: none;
      overflow: hidden;
      font-size: clamp(14px, 2.6vw, 20px);
      line-height: 1;
      letter-spacing: 0.02em;
    }
    .entity {
      position: absolute;
      transform: translate(-50%, -50%);
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: end;
      gap: 10px;
    }
    .hotbar {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 6px;
      margin: 4px 0;
    }
    .hotkey-slot {
      border: 1px solid #2a3552;
      border-radius: 8px;
      background: #0d1322;
      color: #b9c7ec;
      font-size: 12px;
      padding: 6px;
      min-height: 56px;
      display: grid;
      gap: 2px;
      align-content: center;
      text-align: center;
    }
    .hotkey-slot.ready { border-color: #70d890; color: #c8ffd7; }
    .hotkey-slot.cooling { border-color: #7d83b7; color: #9fa8d8; }
    .hotkey-slot.empty { opacity: 0.7; }
    .stick {
      width: min(42vw, 180px);
      aspect-ratio: 1;
      border: 2px solid #2a3452;
      border-radius: 50%;
      position: relative;
      background: radial-gradient(circle at center, #12192b 0%, #0d1220 70%);
    }
    .knob {
      width: 44%;
      aspect-ratio: 1;
      border-radius: 50%;
      background: #6a7fb4;
      opacity: 0.85;
      position: absolute;
      left: 28%;
      top: 28%;
      pointer-events: none;
    }
    .buttons {
      display: grid;
      gap: 8px;
      align-self: center;
      justify-items: center;
    }
    button, label {
      font: inherit;
      color: var(--fg);
      background: var(--panel);
      border: 1px solid #2a3552;
      border-radius: 8px;
      padding: 8px 10px;
    }
    button:active { transform: scale(0.97); }
    .opts { display: grid; gap: 6px; font-size: 12px; color: var(--muted); }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(2,5,10,0.88);
      display: none;
      place-items: center;
      z-index: 10;
      padding: 16px;
    }
    .card {
      max-width: 720px;
      width: 100%;
      border: 1px solid #2d3f6d;
      background: #0e1424;
      border-radius: 12px;
      padding: 12px;
    }
    .choices { display: grid; gap: 8px; }
    .choice { width: 100%; text-align: left; border-left: 4px solid var(--accent); }
    .glyph { display: inline-block; }
  </style>
</head>
<body>
  <div class="app">
    <div class="hud">
      <div>
        <div>HP</div>
        <div class="bar"><div id="hpFill" class="fill hp-fill" style="width:100%"></div></div>
        <div>XP</div>
        <div class="bar"><div id="xpFill" class="fill xp-fill" style="width:0%"></div></div>
      </div>
      <div id="stats">Lv 1 · 00:00 · KOs 0</div>
    </div>

    <div class="screen-wrap">
      <pre id="screen"></pre>
      <div id="entityLayer"></div>
    </div>

    <div id="hotbar" class="hotbar"></div>

    <div class="controls">
      <div id="moveStick" class="stick"><div class="knob"></div></div>
      <div class="buttons">
        <button id="abilityBtn">RELIC BURST</button>
        <div class="opts">
          <label><input id="autoAim" type="checkbox" checked /> Auto-aim</label>
          <label><input id="autoFire" type="checkbox" checked /> Auto-fire</label>
        </div>
      </div>
      <div id="aimStick" class="stick"><div class="knob"></div></div>
    </div>
  </div>

  <div id="upgradeOverlay" class="overlay">
    <div class="card">
      <h3>Level Up — choose 1</h3>
      <div id="choices" class="choices"></div>
    </div>
  </div>

  <script>
    const GRID_W = 48, GRID_H = 27;
    const TICK = 1000 / 30;

    const state = {
      timeSec: 0,
      kills: 0,
      paused: false,
      level: 1,
      xp: 0,
      xpToLevel: 10,
      player: {
        x: 0, y: 0,
        hp: 30, maxHp: 30,
        moveSpeed: 5.4,
        damage: 1,
        pickupRadius: 1.8,
        cooldownMs: 520,
        lastShot: 0,
        aimX: 1, aimY: 0,
        whipLevel: 0,
        garlicLevel: 0,
        stakesLevel: 1,
        batsLevel: 0,
      },
      enemies: [], bullets: [], gems: [], pickups: [], fx: [], clones: [],
      activeWeapon: 'rifle',
      configs: { upgrades: [], enemyTypes: [], waves: [], levels: [] },
      levelDef: null,
      nextSpawnAt: 0,
      nextBossAt: 0,
      joysticks: {
        move: { x:0, y:0, active:false },
        aim:  { x:1, y:0, active:false }
      },
      walls: [],
      flowField: [],
      nextFlowUpdate: 0,
      levelStartTime: 0,
      levelIndex: 0,
      shapeName: '',
      movement: { vx: 0, vy: 0 },
      abilitySlots: [],
      abilityOrder: ['teleportStep', 'sentinelClone', 'graveWall'],
      phaseWalkUntil: 0,
      entityScale: 1,
      upgradeLevels: {}
    };

    const screen = document.getElementById('screen');
    const entityLayer = document.getElementById('entityLayer');
    const hotbar = document.getElementById('hotbar');
    const hpFill = document.getElementById('hpFill');
    const xpFill = document.getElementById('xpFill');
    const stats = document.getElementById('stats');
    const overlay = document.getElementById('upgradeOverlay');
    const choices = document.getElementById('choices');

    function fmtTime(s){ const m = Math.floor(s/60); const r = Math.floor(s%60); return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`; }

    const UPGRADE_COLORS = {
      weapon: '#ff8fab',
      gothic: '#d787ff',
      alchemy: '#7af1a4',
      wasteland: '#ffd166',
      relic: '#8bd3ff',
      ritual: '#ff9a76'
    };


    const WEAPON_DROPS = [
      { id: 'rifle', name: 'Rifle', glyph: 'R', color: '#ffd166', cooldownMult: 1, damageMult: 1, speed: 11, life: 0.9, pierce: 0, spread: 0, projectiles: 1, ricochet: false },
      { id: 'machineGun', name: 'Machine Gun', glyph: 'M', color: '#9ae7ff', cooldownMult: 0.5, damageMult: 0.65, speed: 12, life: 0.8, pierce: 0, spread: 0.04, projectiles: 1, ricochet: false },
      { id: 'laser', name: 'Laser', glyph: 'L', color: '#ff7aff', cooldownMult: 2.1, damageMult: 3.8, speed: 14.5, life: 1.1, pierce: 999, spread: 0, projectiles: 1, ricochet: false },
      { id: 'shotgun', name: 'Shotgun', glyph: 'S', color: '#ffb347', cooldownMult: 1.45, damageMult: 0.8, speed: 10.4, life: 0.55, pierce: 0, spread: 0.24, projectiles: 4, ricochet: false }
    ];

    const ABILITY_META = {
      teleportStep: {
        id: 'teleportStep',
        key: '1',
        name: 'Mist Step',
        desc: 'Teleport in the direction you are moving.',
        baseCooldown: 9500,
        maxLevel: 5,
        baseCharges: 1
      },
      sentinelClone: {
        id: 'sentinelClone',
        key: '2',
        name: 'Pale Doppel',
        desc: 'Place a static clone that shoots nearby enemies.',
        baseCooldown: 13000,
        maxLevel: 5,
        baseCharges: 1
      },
      graveWall: {
        id: 'graveWall',
        key: '3',
        name: 'Bone Rampart',
        desc: 'Build a wall trail where you walk for 5s.',
        baseCooldown: 15000,
        maxLevel: 5,
        baseCharges: 1
      }
    };

    function escapeHtml(ch){
      if(ch === '&') return '&amp;';
      if(ch === '<') return '&lt;';
      if(ch === '>') return '&gt;';
      return ch;
    }

    function setCell(glyphs, x, y, char, color){
      if(x<0||y<0||x>=GRID_W||y>=GRID_H) return;
      glyphs[y][x] = { char, color };
    }

    function upgradeColor(up){
      if(up.theme && UPGRADE_COLORS[up.theme]) return UPGRADE_COLORS[up.theme];
      if(['whip','stakes','bats'].includes(up.id)) return UPGRADE_COLORS.weapon;
      if(['garlic'].includes(up.id)) return UPGRADE_COLORS.alchemy;
      if(['damage','fireRate'].includes(up.id)) return UPGRADE_COLORS.wasteland;
      return UPGRADE_COLORS.relic;
    }
    function rand(a,b){ return Math.random()*(b-a)+a; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    function normalize(x,y){ const d=Math.hypot(x,y)||1; return {x:x/d, y:y/d}; }

    async function loadJson(path){ const r = await fetch(path); if(!r.ok) throw new Error(`Missing ${path}`); return r.json(); }
    async function boot(){
      state.configs.upgrades = await loadJson('./upgrades.json');
      state.configs.enemyTypes = await loadJson('./enemy-types.json');
      state.configs.waves = await loadJson('./waves.json');
      state.configs.levels = await loadJson('./levels.json');
      state.levelDef = state.configs.levels[0];
      state.levelStartTime = 0;
      state.nextBossAt = state.levelDef.bossIntervalSec;
      resetPlayer();
      rebuildLevelGeometry();
      bindStick('moveStick', 'move');
      bindStick('aimStick', 'aim');
      initAbilitySlots();
      bindHotkeys();
      document.getElementById('abilityBtn').addEventListener('click', panicBomb);
      setInterval(loop, TICK);
    }

    function initAbilitySlots(){
      state.abilitySlots = state.abilityOrder.map(id => ({
        id,
        level: 0,
        charges: 0,
        maxCharges: ABILITY_META[id].baseCharges,
        cooldownMs: ABILITY_META[id].baseCooldown,
        nextReadyAt: 0
      }));
    }

    function bindHotkeys(){
      window.addEventListener('keydown', (e) => {
        const index = Number(e.key) - 1;
        if(index >= 0 && index < state.abilitySlots.length){
          activateAbilitySlot(index);
        }
      });
    }

    function resetPlayer(){ state.player.x = GRID_W/2; state.player.y = GRID_H/2; }

    function cellBlocked(x, y){
      if(x < 0 || y < 0 || x >= GRID_W || y >= GRID_H) return true;
      return (state.walls[y]?.[x] || 0) > 0;
    }

    function randomOpenCell(){
      for(let i=0;i<300;i++){
        const x = Math.floor(rand(1, GRID_W - 1));
        const y = Math.floor(rand(1, GRID_H - 1));
        if(!cellBlocked(x, y)) return {x: x + 0.5, y: y + 0.5};
      }
      return {x: GRID_W / 2, y: GRID_H / 2};
    }

    function buildMaze(){
      const walls = Array.from({length: GRID_H}, (_, y) => Array.from({length: GRID_W}, (_, x) => x % 2 === 0 || y % 2 === 0 ? 7 : 0));
      const visited = Array.from({length: GRID_H}, () => Array(GRID_W).fill(false));
      const stack = [{x: 1, y: 1}];
      visited[1][1] = true;
      walls[1][1] = 0;
      const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
      while(stack.length){
        const cur = stack[stack.length - 1];
        const moves = dirs
          .map(([dx,dy])=>({x:cur.x+dx,y:cur.y+dy,dx,dy}))
          .filter(n => n.x > 0 && n.y > 0 && n.x < GRID_W - 1 && n.y < GRID_H - 1 && !visited[n.y][n.x]);
        if(!moves.length){ stack.pop(); continue; }
        const pick = moves[Math.floor(Math.random() * moves.length)];
        visited[pick.y][pick.x] = true;
        walls[cur.y + pick.dy / 2][cur.x + pick.dx / 2] = 0;
        walls[pick.y][pick.x] = 0;
        stack.push({x: pick.x, y: pick.y});
      }
      return walls;
    }

    function emptyWallGrid(){ return Array.from({length: GRID_H}, () => Array(GRID_W).fill(0)); }
    function paintCell(walls, x, y, hp = 7){ if(x>=1&&y>=1&&x<GRID_W-1&&y<GRID_H-1) walls[y][x] = hp; }

    function carveShape(shape){
      const walls = emptyWallGrid();
      const cx = Math.floor(GRID_W / 2), cy = Math.floor(GRID_H / 2);
      if(shape === 'skull'){
        for(let y=2;y<GRID_H-3;y++) for(let x=5;x<GRID_W-5;x++){
          const dx = (x-cx)/15, dy = (y-(cy-2))/9;
          if(dx*dx + dy*dy < 1) paintCell(walls, x, y, 8);
        }
        for(let y=cy-5;y<=cy-2;y++) for(const x of [cx-6,cx-5,cx+5,cx+6]) walls[y][x] = 0;
        for(let y=cy+2;y<cy+8;y++) for(let x=cx-7;x<=cx+7;x++) if((x+y)%3!==0) paintCell(walls, x, y, 6);
      }
      if(shape === 'sword'){
        for(let y=4;y<GRID_H-5;y++) for(let x=cx-1;x<=cx+1;x++) paintCell(walls, x, y, 8);
        for(let i=0;i<6;i++) for(let x=cx-3+i;x<=cx+3-i;x++) paintCell(walls, x, 3+i, 8);
        for(let x=cx-5;x<=cx+5;x++) paintCell(walls, x, GRID_H-6, 7);
        for(let y=GRID_H-5;y<GRID_H-2;y++) for(let x=cx-2;x<=cx+2;x++) paintCell(walls, x, y, 7);
      }
      if(shape === 'potion'){
        for(let y=4;y<9;y++) for(let x=cx-2;x<=cx+2;x++) paintCell(walls, x, y, 7);
        for(let y=8;y<GRID_H-4;y++) for(let x=6;x<GRID_W-6;x++){
          const dx=(x-cx)/14, dy=(y-(cy+2))/9;
          if(dx*dx + dy*dy < 1) paintCell(walls, x, y, 7);
        }
      }
      if(shape === 'shield'){
        for(let y=3;y<GRID_H-3;y++) for(let x=6;x<GRID_W-6;x++){
          const dx=(x-cx)/14, dy=(y-(cy-2))/10;
          if(dx*dx + dy*dy < 1.05 && y < cy+6-Math.abs(dx*3)) paintCell(walls, x, y, 8);
        }
      }
      if(shape === 'tree'){
        for(let y=5;y<cy+5;y++) for(let x=8;x<GRID_W-8;x++){
          const dx=(x-cx)/(15-(y-5)*0.4), dy=(y-(cy-2))/10;
          if(dx*dx + dy*dy < 1) paintCell(walls, x, y, 6);
        }
        for(let y=cy+4;y<GRID_H-2;y++) for(let x=cx-2;x<=cx+2;x++) paintCell(walls, x, y, 9);
      }
      if(shape === 'mountain'){
        for(let y=4;y<GRID_H-2;y++){
          const width = Math.floor((y-3) * 1.25);
          for(let x=cx-width; x<=cx+width; x++) if(Math.random() > 0.08 || y > cy+4) paintCell(walls, x, y, 8);
        }
      }
      return walls;
    }

    function generateWalls(){
      const pattern = state.levelDef?.wallPattern || 'drunken';
      const density = state.levelDef?.wallDensity || 0.2;
      const walls = emptyWallGrid();
      if(pattern === 'drunken'){
        const target = Math.floor(GRID_W * GRID_H * density);
        let x = Math.floor(GRID_W / 2), y = Math.floor(GRID_H / 2), carved = 0;
        while(carved < target){
          if(x > 1 && y > 1 && x < GRID_W - 2 && y < GRID_H - 2 && !walls[y][x]){ walls[y][x] = 7; carved++; }
          const d = [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random() * 4)];
          x = clamp(x + d[0], 1, GRID_W - 2);
          y = clamp(y + d[1], 1, GRID_H - 2);
        }
      } else if(pattern === 'cellular'){
        for(let y=1;y<GRID_H-1;y++) for(let x=1;x<GRID_W-1;x++) walls[y][x] = Math.random() < density ? 7 : 0;
        for(let pass=0; pass<3; pass++){
          const next = walls.map(row => row.slice());
          for(let y=1;y<GRID_H-1;y++) for(let x=1;x<GRID_W-1;x++){
            let n = 0;
            for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++) if(ox||oy) n += walls[y+oy][x+ox] ? 1 : 0;
            next[y][x] = n >= 5 ? 7 : 0;
          }
          for(let y=1;y<GRID_H-1;y++) for(let x=1;x<GRID_W-1;x++) walls[y][x] = next[y][x];
        }
      } else if(pattern === 'maze'){
        return buildMaze();
      } else if(pattern === 'rings'){
        const cx = Math.floor(GRID_W/2), cy = Math.floor(GRID_H/2);
        for(let y=1;y<GRID_H-1;y++) for(let x=1;x<GRID_W-1;x++){
          const dx = x - cx, dy = y - cy;
          const d = Math.hypot(dx * 0.7, dy);
          if((Math.abs(d - 6) < 0.7 || Math.abs(d - 11) < 0.7) && !(Math.abs(dx) < 2 || Math.abs(dy) < 2)) walls[y][x] = 8;
        }
      } else if(pattern === 'shape'){
        const shapes = ['skull', 'sword', 'potion', 'shield', 'tree', 'mountain'];
        state.shapeName = shapes[Math.floor(Math.random() * shapes.length)];
        return carveShape(state.shapeName);
      }
      return walls;
    }

    function rebuildLevelGeometry(){
      state.walls = generateWalls();
      const spawn = randomOpenCell();
      state.player.x = spawn.x;
      state.player.y = spawn.y;
      state.flowField = [];
      state.nextFlowUpdate = 0;
      state.movement.vx = 0;
      state.movement.vy = 0;
    }

    function updateFlowField(){
      const tx = clamp(Math.floor(state.player.x), 0, GRID_W - 1);
      const ty = clamp(Math.floor(state.player.y), 0, GRID_H - 1);
      const flow = Array.from({length: GRID_H}, () => Array(GRID_W).fill(Infinity));
      const queue = [{x: tx, y: ty}];
      flow[ty][tx] = 0;
      for(let i=0;i<queue.length;i++){
        const c = queue[i], base = flow[c.y][c.x] + 1;
        for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx = c.x + dx, ny = c.y + dy;
          if(nx < 0 || ny < 0 || nx >= GRID_W || ny >= GRID_H || cellBlocked(nx, ny)) continue;
          if(base < flow[ny][nx]){ flow[ny][nx] = base; queue.push({x:nx,y:ny}); }
        }
      }
      state.flowField = flow;
    }

    function bindStick(id, key){
      const el = document.getElementById(id), knob = el.querySelector('.knob');
      const joy = state.joysticks[key];
      function update(clientX, clientY){
        const rect = el.getBoundingClientRect();
        const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
        let dx = (clientX - cx) / (rect.width/2), dy = (clientY - cy) / (rect.height/2);
        const mag = Math.hypot(dx,dy); if(mag > 1){ dx/=mag; dy/=mag; }
        joy.x = dx; joy.y = dy;
        knob.style.left = `${28 + dx * 26}%`;
        knob.style.top = `${28 + dy * 26}%`;
      }
      function clear(){ joy.x=0; joy.y=0; joy.active=false; knob.style.left='28%'; knob.style.top='28%'; }
      el.addEventListener('pointerdown', e=>{ joy.active=true; update(e.clientX,e.clientY); el.setPointerCapture(e.pointerId); });
      el.addEventListener('pointermove', e=> joy.active && update(e.clientX,e.clientY));
      el.addEventListener('pointerup', clear);
      el.addEventListener('pointercancel', clear);
    }

    function getEnemyType(id){ return state.configs.enemyTypes.find(e => e.id === id); }
    function getWeaponDrop(id){ return WEAPON_DROPS.find(w => w.id === id) || WEAPON_DROPS[0]; }
    function randomWeaponDrop(){ return WEAPON_DROPS[Math.floor(Math.random() * WEAPON_DROPS.length)]; }
    function pickWeighted(mix){
      const total = mix.reduce((s,m)=>s+m.weight,0); let roll = Math.random()*total;
      for(const m of mix){ roll -= m.weight; if(roll <= 0) return m.type; }
      return mix[0].type;
    }

    function currentWave(){
      const t = state.timeSec;
      return state.configs.waves.find(w => t >= w.startSec && t < w.endSec) || state.configs.waves[state.configs.waves.length-1];
    }

    function spawnEnemy(typeId){
      const t = getEnemyType(typeId); if(!t) return;
      let x=0,y=0;
      for(let i=0;i<40;i++){
        const side = Math.floor(Math.random()*4);
        if(side===0){ x=rand(0,GRID_W); y=1; }
        if(side===1){ x=GRID_W-2; y=rand(0,GRID_H); }
        if(side===2){ x=rand(0,GRID_W); y=GRID_H-2; }
        if(side===3){ x=1; y=rand(0,GRID_H); }
        if(!cellBlocked(Math.floor(x), Math.floor(y))) break;
      }
      state.enemies.push({
        x,y,type:t.id,char:t.char,color:t.color,
        hp:t.hp + state.timeSec*0.05,
        speed:t.speed*1.2,
        touchDamage:t.touchDamage,
        xp:t.xp,
        boss: !!t.boss,
        hitFlash:0,
        size: t.size || 1,
        canBreakWalls: t.canBreakWalls !== false,
        wallDamage: t.wallDamage || 0.6,
        dashWindup: 0,
        dashCooldown: 0,
        dashDirX: 0,
        dashDirY: 0,
        dashing: 0,
        wallHitTicks: 0
      });
    }

    function breakWallTowardEntity(entity, tx, ty, dt){
      const nx = normalize(tx - entity.x, ty - entity.y);
      const wx = entity.x + nx.x * 0.8;
      const wy = entity.y + nx.y * 0.8;
      const damage = Math.max(0.1, entity.wallDamage * dt * 10);
      return damageWallAt(wx, wy, damage);
    }

    function spawnParticles(kind, x, y, amount){
      const configs = {
        blood: { chars: ['.'], colors: ['#ff3b3b', '#ff4a4a', '#ff5a5a'], speed: [2.2, 5.3], life: [0.22, 0.55] },
        blast: { chars: ['+', '*', 'x', ':'], colors: ['#ffd166', '#ff9f40', '#ff6b35'], speed: [0.8, 2.6], life: [0.15, 0.55] }
      };
      const cfg = configs[kind];
      if(!cfg) return;
      for(let i=0;i<amount;i++){
        const a = Math.random() * Math.PI * 2;
        const speed = rand(cfg.speed[0], cfg.speed[1]);
        state.fx.push({
          x,
          y,
          vx: Math.cos(a) * speed,
          vy: Math.sin(a) * speed,
          life: rand(cfg.life[0], cfg.life[1]),
          char: cfg.chars[Math.floor(Math.random() * cfg.chars.length)],
          color: cfg.colors[Math.floor(Math.random() * cfg.colors.length)]
        });
      }
    }

    function fxLogic(dt){
      for(let i=state.fx.length-1;i>=0;i--){
        const f = state.fx[i];
        f.life -= dt;
        f.x += f.vx * dt;
        f.y += f.vy * dt;
        f.vx *= 0.9;
        f.vy *= 0.9;
        if(f.life <= 0) state.fx.splice(i, 1);
      }
    }

    function fire(){
      const p = state.player;
      const now = performance.now();
      const canFire = document.getElementById('autoFire').checked || state.joysticks.aim.active;
      const weapon = getWeaponDrop(state.activeWeapon);
      const cooldown = Math.max(90, p.cooldownMs * weapon.cooldownMult);
      if(!canFire || now - p.lastShot < cooldown) return;
      p.lastShot = now;
      const aim = normalize(p.aimX, p.aimY);
      const weaponSpread = weapon.spread || 0;
      const upgradeSpread = p.stakesLevel >= 3 ? 0.07 : 0;
      const spread = weaponSpread + upgradeSpread;
      const weaponCount = weapon.id === 'shotgun' ? (Math.random() < 0.5 ? 3 : 4) : weapon.projectiles;
      const count = Math.max(1, weaponCount + (p.stakesLevel >= 5 ? 1 : 0));
      for(let i=0;i<count;i++){
        const t = count === 1 ? 0 : (i / (count - 1)) * 2 - 1;
        const a = Math.atan2(aim.y, aim.x) + t * spread;
        state.bullets.push({
          x:p.x, y:p.y,
          vx:Math.cos(a)*(weapon.speed + p.stakesLevel * 0.4), vy:Math.sin(a)*(weapon.speed + p.stakesLevel * 0.4),
          dmg:(2 + p.damage + p.stakesLevel * 0.45) * weapon.damageMult,
          life:weapon.life,
          pierce: weapon.pierce + Math.floor(p.stakesLevel/2),
          ricochet: p.stakesLevel >= 4 ? 1 : 0,
          char: weapon.id === 'laser' ? '=' : (p.stakesLevel >= 4 ? '*' : '.')
        });
      }
    }

    function whipTick(dt){
      const p = state.player;
      if(p.whipLevel <= 0) return;
      if(Math.random() > dt * (0.7 + p.whipLevel*0.2)) return;
      const arc = Math.PI * (0.35 + p.whipLevel * 0.04);
      const forward = Math.atan2(p.aimY,p.aimX);
      for(const e of state.enemies){
        const d = dist(p,e); if(d > 3.8 + p.whipLevel*0.25) continue;
        const a = Math.atan2(e.y-p.y,e.x-p.x);
        let diff = Math.abs(a-forward); if(diff > Math.PI) diff = 2*Math.PI - diff;
        if(diff <= arc/2){
          e.hp -= 3 + p.damage + p.whipLevel;
          const n = normalize(e.x-p.x,e.y-p.y);
          e.x += n.x*(0.5 + p.whipLevel*0.08);
          e.y += n.y*(0.5 + p.whipLevel*0.08);
          e.hitFlash = 0.15;
        }
      }
    }

    function garlicTick(dt){
      const p = state.player;
      if(p.garlicLevel <= 0) return;
      const r = 1.2 + p.garlicLevel * 0.45;
      for(const e of state.enemies){
        if(dist(p,e) <= r){ e.hp -= dt * (2 + p.garlicLevel + p.damage*0.4); e.hitFlash = 0.05; }
      }
    }

    function batsTick(dt){
      if(state.player.batsLevel <= 0) return;
      const p = state.player;
      const count = p.batsLevel + 1;
      for(let i=0;i<count;i++){
        const a = state.timeSec*2.2 + (Math.PI*2/count)*i;
        const r = 1.8 + p.batsLevel*0.25;
        const bx = p.x + Math.cos(a)*r, by = p.y + Math.sin(a)*r;
        for(const e of state.enemies){
          if(Math.hypot(e.x-bx,e.y-by) < 0.8){
            e.hp -= dt*(7 + p.batsLevel + p.damage*0.4);
            e.hitFlash = 0.05;
          }
        }
      }
    }

    function cloneLogic(dt){
      for(let i=state.clones.length-1;i>=0;i--){
        const c = state.clones[i];
        c.ttl -= dt;
        if(c.ttl <= 0){ state.clones.splice(i,1); continue; }
        let target = null;
        for(const e of state.enemies){
          if(dist(c, e) <= c.range && (!target || dist(c, e) < dist(c, target))) target = e;
        }
        if(target){
          target.hp -= c.dps * dt;
          target.hitFlash = 0.06;
          if(Math.random() < dt * 12) state.fx.push({ x: c.x, y: c.y, vx: (target.x-c.x)*2, vy: (target.y-c.y)*2, life: 0.1, char: '•', color: '#c9d4ff' });
        }
      }
    }

    function panicBomb(){
      for(const e of state.enemies){
        const d = dist(state.player,e);
        if(d < 8){ e.hp -= 26; e.hitFlash = 0.2; }
      }
      state.player.hp = clamp(state.player.hp + 4, 0, state.player.maxHp);
    }

    function circleBlocked(x, y, radius = 0.3){
      return cellBlocked(Math.floor(x), Math.floor(y))
        || cellBlocked(Math.floor(x + radius), Math.floor(y))
        || cellBlocked(Math.floor(x - radius), Math.floor(y))
        || cellBlocked(Math.floor(x), Math.floor(y + radius))
        || cellBlocked(Math.floor(x), Math.floor(y - radius));
    }

    function enemyLogic(dt){
      const p = state.player;
      for(const e of state.enemies){
        const n = normalize(p.x - e.x, p.y - e.y);
        let moveX = n.x;
        let moveY = n.y;
        let speed = e.speed * dt;

        if(e.type === 'juggernaut'){
          e.dashCooldown = Math.max(0, e.dashCooldown - dt);
          e.dashing = Math.max(0, e.dashing - dt);
          if(e.dashing > 0){
            moveX = e.dashDirX;
            moveY = e.dashDirY;
            speed = e.speed * 5.8 * dt;
          } else if(e.dashWindup > 0){
            e.dashWindup -= dt;
            moveX = 0;
            moveY = 0;
            speed = 0;
            if(e.dashWindup <= 0){
              e.dashing = 0.34;
              e.dashCooldown = 2.2;
            }
          } else if(e.dashCooldown <= 0){
            const dir = normalize((p.x + rand(-1, 1)) - e.x, (p.y + rand(-1, 1)) - e.y);
            e.dashDirX = dir.x;
            e.dashDirY = dir.y;
            e.dashWindup = 0.75;
          }
        }

        const nextX = clamp(e.x + moveX * speed, 0, GRID_W - 0.001);
        const nextY = clamp(e.y + moveY * speed, 0, GRID_H - 0.001);
        const steer = Math.sin((state.timeSec * 6) + e.x * 1.7 + e.y * 2.3) * speed * 0.45;
        const blockX = circleBlocked(nextX, e.y, 0.3 * (e.size || 1));
        const blockY = circleBlocked(e.x, nextY, 0.3 * (e.size || 1));

        if(!blockX) e.x = nextX;
        else if(!circleBlocked(e.x, e.y + steer, 0.3 * (e.size || 1))) e.y = clamp(e.y + steer, 0, GRID_H - 0.001);
        else if(e.canBreakWalls) e.wallHitTicks += breakWallTowardEntity(e, p.x, p.y, dt) ? 1 : 0;

        if(!blockY) e.y = nextY;
        else if(!circleBlocked(e.x + steer, e.y, 0.3 * (e.size || 1))) e.x = clamp(e.x + steer, 0, GRID_W - 0.001);
        else if(e.canBreakWalls) e.wallHitTicks += breakWallTowardEntity(e, p.x, p.y, dt) ? 1 : 0;

        if(dist(e,p) < 0.65 + (e.size - 1) * 0.45){ p.hp -= e.touchDamage*dt; }
        e.hitFlash = Math.max(0, e.hitFlash - dt);
      }
      for(let i=state.enemies.length-1;i>=0;i--){
        const e = state.enemies[i];
        if(e.hp <= 0){
          spawnParticles('blood', e.x, e.y, e.boss ? 24 : 12);
          state.kills++;
          state.gems.push({x:e.x,y:e.y,v:e.xp});
          if(e.boss || Math.random() < 0.13){
            const drop = randomWeaponDrop();
            state.pickups.push({ x: e.x, y: e.y, weaponId: drop.id });
          }
          state.enemies.splice(i,1);
        }
      }
    }

    function damageWallAt(x, y, dmg){
      const gx = clamp(Math.floor(x), 0, GRID_W - 1);
      const gy = clamp(Math.floor(y), 0, GRID_H - 1);
      const hp = state.walls[gy]?.[gx] || 0;
      if(hp <= 0) return false;
      const nextHp = Math.max(0, hp - dmg);
      state.walls[gy][gx] = nextHp;
      if(nextHp <= 0) spawnParticles('blast', gx + 0.5, gy + 0.5, 8);
      return true;
    }

    function bulletLogic(dt){
      for(let i=state.bullets.length-1;i>=0;i--){
        const b = state.bullets[i];
        b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt;
        const hitWall = damageWallAt(b.x, b.y, Math.max(1, b.dmg * 0.9));
        if(b.x<0||b.x>=GRID_W||b.y<0||b.y>=GRID_H||hitWall){
          if(b.ricochet>0){ b.ricochet--; b.vx*=-1; b.vy*=-1; }
          else { state.bullets.splice(i,1); continue; }
        }
        let used = false;
        for(const e of state.enemies){
          if(Math.hypot(e.x-b.x,e.y-b.y) < 0.55){
            e.hp -= b.dmg; e.hitFlash=0.07;
            if(b.pierce > 0){ b.pierce--; } else { used = true; break; }
          }
        }
        if(used || b.life <= 0) state.bullets.splice(i,1);
      }
    }

    function pickupGems(){
      const p = state.player;
      for(let i=state.gems.length-1;i>=0;i--){
        const g = state.gems[i], d = dist(p,g);
        if(d < p.pickupRadius){
          p.xpGain = (p.xpGain||0)+g.v;
          state.xp += g.v;
          state.gems.splice(i,1);
        } else if(d < p.pickupRadius + 2.5){
          const n = normalize(p.x-g.x,p.y-g.y);
          g.x += n.x*0.06; g.y += n.y*0.06;
        }
      }
      for(let i=state.pickups.length-1;i>=0;i--){
        const pickup = state.pickups[i];
        if(dist(p, pickup) < 0.9){
          state.activeWeapon = pickup.weaponId;
          state.pickups.splice(i, 1);
        }
      }
      while(state.xp >= state.xpToLevel){
        state.xp -= state.xpToLevel;
        state.level++;
        state.xpToLevel = Math.floor(state.xpToLevel * 1.25 + 4);
        levelUp();
      }
    }

    function levelUp(){
      state.paused = true;
      overlay.style.display = 'grid';
      const available = state.configs.upgrades.filter(canTakeUpgrade);
      const picks = [...available].sort(()=>Math.random()-0.5).slice(0,3);
      choices.innerHTML = '';
      if(!picks.length){
        overlay.style.display='none';
        state.paused = false;
        return;
      }
      for(const up of picks){
        const btn = document.createElement('button');
        btn.className = 'choice';
        btn.style.borderLeftColor = upgradeColor(up);
        btn.style.color = upgradeColor(up);
        btn.textContent = `${up.name}: ${upgradeSummary(up)}`;
        btn.onclick = () => { applyUpgrade(up); overlay.style.display='none'; state.paused=false; };
        choices.appendChild(btn);
      }
    }

    function canTakeUpgrade(up){
      const p = state.player;
      const level = state.upgradeLevels[up.id] || 0;
      if(level >= (up.maxLevel || 99)) return false;
      if(up.id in ABILITY_META){
        const slot = state.abilitySlots.find(s => s.id === up.id);
        return !!slot;
      }
      if(up.id === 'extraAbilityUse') return state.abilitySlots.some(s => s.level > 0 && s.maxCharges < 2);
      const map = { whip: 'whipLevel', garlic: 'garlicLevel', stakes: 'stakesLevel', bats: 'batsLevel' };
      const k = map[up.id];
      if(k) return true;
      return true;
    }

    function applyUpgrade(up){
      const p = state.player;
      state.upgradeLevels[up.id] = (state.upgradeLevels[up.id] || 0) + 1;
      if(up.id in ABILITY_META){
        const slot = state.abilitySlots.find(s => s.id === up.id);
        if(slot){
          slot.level++;
          slot.maxCharges = ABILITY_META[up.id].baseCharges + Math.floor(slot.level >= 3 ? 1 : 0);
          slot.charges = Math.max(slot.charges, slot.maxCharges);
          slot.cooldownMs = Math.max(2400, ABILITY_META[up.id].baseCooldown - slot.level * 700);
        }
      }
      if(up.id === 'extraAbilityUse'){
        for(const slot of state.abilitySlots){
          if(slot.level > 0 && slot.maxCharges < 2){
            slot.maxCharges = 2;
            slot.charges = Math.max(slot.charges, slot.maxCharges);
          }
        }
      }
      if(up.id === 'phaseStride'){
        state.phaseWalkUntil = Math.max(state.phaseWalkUntil, state.timeSec + 10);
      }
      if(up.id === 'whip') p.whipLevel++;
      if(up.id === 'garlic') p.garlicLevel++;
      if(up.id === 'stakes') p.stakesLevel++;
      if(up.id === 'bats') p.batsLevel++;
      const fx = up.effectsPerLevel || {};
      if(fx.damage) p.damage += fx.damage;
      if(fx.cooldownMs) p.cooldownMs += fx.cooldownMs;
      if(fx.moveSpeed) p.moveSpeed += fx.moveSpeed;
      if(fx.pickupRadius) p.pickupRadius += fx.pickupRadius;
      if(fx.maxHp){ p.maxHp += fx.maxHp; p.hp += (fx.heal || 0); }
      p.hp = clamp(p.hp,0,p.maxHp);
    }

    function activateAbilitySlot(index){
      const slot = state.abilitySlots[index];
      if(!slot || slot.level <= 0 || slot.charges <= 0) return;
      const now = performance.now();
      if(now < slot.nextReadyAt) return;
      const used = useAbility(slot);
      if(!used) return;
      slot.charges--;
      slot.nextReadyAt = now + slot.cooldownMs;
    }

    function useAbility(slot){
      const p = state.player;
      const moveVec = normalize(state.movement.vx || p.aimX, state.movement.vy || p.aimY);
      if(slot.id === 'teleportStep'){
        const range = 2.7 + slot.level * 0.9;
        for(let step=1; step<=10; step++){
          const tx = clamp(p.x + moveVec.x * range * (step / 10), 0, GRID_W - 0.001);
          const ty = clamp(p.y + moveVec.y * range * (step / 10), 0, GRID_H - 0.001);
          if(!circleBlocked(tx, ty, 0.28)){ p.x = tx; p.y = ty; }
        }
        spawnParticles('blast', p.x, p.y, 14 + slot.level * 2);
        return true;
      }
      if(slot.id === 'sentinelClone'){
        state.clones.push({
          x: p.x,
          y: p.y,
          ttl: 5 + slot.level * 1.5,
          dps: 8 + slot.level * 4,
          range: 4 + slot.level * 0.6
        });
        return true;
      }
      if(slot.id === 'graveWall'){
        p.wallTrailUntil = state.timeSec + 5;
        p.wallTrailPower = 6 + slot.level * 1.2;
        return true;
      }
      return false;
    }


    function upgradeSummary(up){
      const parts = [up.description];
      const fx = up.effectsPerLevel || {};
      if(fx.damage) parts.push(`DMG +${fx.damage}`);
      if(fx.cooldownMs) parts.push(`Fire rate ${fx.cooldownMs < 0 ? '+' : '-'}${Math.abs(fx.cooldownMs)}ms`);
      if(fx.moveSpeed) parts.push(`Move +${fx.moveSpeed.toFixed(2)}`);
      if(fx.pickupRadius) parts.push(`Pickup +${fx.pickupRadius.toFixed(2)}`);
      if(fx.maxHp) parts.push(`Max HP +${fx.maxHp}`);
      if(fx.heal) parts.push(`Heal +${fx.heal}`);
      return parts.join(' · ');
    }

    function spawnLogic(){
      const now = performance.now();
      const w = currentWave();
      if(now >= state.nextSpawnAt){
        const roll = Math.random() < 0.025;
        spawnEnemy(roll ? 'juggernaut' : pickWeighted(w.mix));
        state.nextSpawnAt = now + w.spawnEveryMs;
      }
      if(state.timeSec >= state.nextBossAt){
        spawnEnemy('boss');
        state.nextBossAt += state.levelDef.bossIntervalSec;
      }
    }


    function maybeAdvanceLevel(){
      if(state.timeSec - state.levelStartTime < state.levelDef.durationSec) return;
      state.levelIndex = (state.levelIndex + 1) % state.configs.levels.length;
      state.levelDef = state.configs.levels[state.levelIndex];
      state.levelStartTime = state.timeSec;
      state.nextBossAt = state.timeSec + state.levelDef.bossIntervalSec;
      state.shapeName = '';
      rebuildLevelGeometry();
    }

    function inputLogic(dt){
      const p = state.player;
      const move = state.joysticks.move;
      const m = normalize(move.x, move.y);
      const accel = 27;
      const drag = 0.83;
      state.movement.vx += (m.x * p.moveSpeed - state.movement.vx) * Math.min(1, dt * accel);
      state.movement.vy += (m.y * p.moveSpeed - state.movement.vy) * Math.min(1, dt * accel);
      if(Math.hypot(move.x, move.y) < 0.1){
        state.movement.vx *= drag;
        state.movement.vy *= drag;
      }
      const nextX = clamp(p.x + state.movement.vx * dt, 0, GRID_W - 0.001);
      const nextY = clamp(p.y + state.movement.vy * dt, 0, GRID_H - 0.001);
      const phasing = state.timeSec < state.phaseWalkUntil;
      if(phasing) damageWallAt(nextX, p.y, dt * 18);
      if(phasing || !circleBlocked(nextX, p.y, 0.32)) p.x = nextX;
      if(phasing) damageWallAt(p.x, nextY, dt * 18);
      if(phasing || !circleBlocked(p.x, nextY, 0.32)) p.y = nextY;

      if((p.wallTrailUntil || 0) > state.timeSec){
        const gx = Math.floor(p.x), gy = Math.floor(p.y);
        if(gx > 1 && gy > 1 && gx < GRID_W - 1 && gy < GRID_H - 1){
          state.walls[gy][gx] = Math.max(state.walls[gy][gx] || 0, p.wallTrailPower || 6);
        }
      }

      const aim = state.joysticks.aim;
      if(aim.active && Math.hypot(aim.x, aim.y) > 0.2){
        p.aimX += (aim.x - p.aimX) * Math.min(1, dt * 20); p.aimY += (aim.y - p.aimY) * Math.min(1, dt * 20);
      } else if(document.getElementById('autoAim').checked && state.enemies.length){
        const nearest = state.enemies.reduce((best,e)=> dist(p,e) < dist(p,best)?e:best, state.enemies[0]);
        p.aimX += (nearest.x - p.x - p.aimX) * Math.min(1, dt * 10); p.aimY += (nearest.y - p.y - p.aimY) * Math.min(1, dt * 10);
      }
      fire();

      for(const slot of state.abilitySlots){
        if(slot.level > 0 && slot.charges < slot.maxCharges && performance.now() >= slot.nextReadyAt){
          slot.charges++;
          if(slot.charges < slot.maxCharges) slot.nextReadyAt = performance.now() + slot.cooldownMs;
        }
      }
    }

    function render(){
      const glyphs = Array.from({length:GRID_H},()=>Array.from({length:GRID_W},()=> ({ char: ' ', color: '' })));
      for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){ const hp = state.walls[y]?.[x] || 0; if(hp <= 0) continue; const char = hp > 6 ? '#': (hp > 3 ? '%' : ':'); const color = hp > 6 ? '#5f78b0' : (hp > 3 ? '#4e6290' : '#3c4d70'); setCell(glyphs, x, y, char, color); }
      for(const g of state.gems){ setCell(glyphs, g.x|0, g.y|0, '+', 'var(--gem)'); }
      for(const pickup of state.pickups){
        const weapon = getWeaponDrop(pickup.weaponId);
        setCell(glyphs, pickup.x|0, pickup.y|0, weapon.glyph, 'var(--pickup)');
      }
      const p = state.player;

      if(p.garlicLevel>0){
        const r = 1.2 + p.garlicLevel*0.45;
        for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){
          const d = Math.hypot(x-p.x,y-p.y);
          if(d>r-0.4 && d<r+0.4 && glyphs[y][x].char===' ') glyphs[y][x]={char:'~',color:'var(--aura)'};
        }
      }

      if(p.batsLevel>0){
        const count = p.batsLevel + 1;
        for(let i=0;i<count;i++){
          const a = state.timeSec*2.2 + (Math.PI*2/count)*i;
          const r = 1.8 + p.batsLevel*0.25;
          const bx = p.x + Math.cos(a) * r;
          const by = p.y + Math.sin(a) * r;
          setCell(glyphs, bx|0, by|0, 'o', 'var(--bat)');
        }
      }

      const lines = glyphs.map(row => row.map(cell => cell.color
        ? `<span class=\"glyph\" style=\"color:${cell.color}\">${escapeHtml(cell.char)}</span>`
        : escapeHtml(cell.char)).join(''));
      screen.innerHTML = lines.join('\n');

      const entities = [];
      const pushEntity = (x, y, char, color, scale = 1, opacity = 1) => {
        entities.push(`<span class="entity" style="left:${(x / GRID_W) * 100}%;top:${(y / GRID_H) * 100}%;color:${color};transform:translate(-50%, -50%) scale(${scale});opacity:${opacity}">${escapeHtml(char)}</span>`);
      };
      for(const b of state.bullets) pushEntity(b.x, b.y, b.char, 'var(--bullet)');
      for(const e of state.enemies){
        const shake = e.type === 'juggernaut' && e.dashWindup > 0 ? (Math.sin(state.timeSec * 65) * 0.15) : 0;
        pushEntity(e.x + shake, e.y, e.char, e.hitFlash > 0 ? '#ffffff' : (e.color || 'var(--enemy)'), e.size || 1);
        if(e.type === 'juggernaut' && e.dashWindup > 0){
          const ax = e.x + e.dashDirX * 1.6;
          const ay = e.y + e.dashDirY * 1.6;
          pushEntity(ax, ay, '➤', '#ffffff', 1.2, 0.95);
        }
      }
      for(const c of state.clones) pushEntity(c.x, c.y, '&', '#c1ccff', 1.15, 0.9);
      for(const f of state.fx) pushEntity(f.x, f.y, f.char, f.color);
      pushEntity(p.x, p.y, '@', 'var(--player)');
      entityLayer.innerHTML = entities.join('');

      hotbar.innerHTML = state.abilitySlots.map(slot => {
        if(slot.level <= 0) return `<div class="hotkey-slot empty">${ABILITY_META[slot.id].key}<br>${ABILITY_META[slot.id].name}<br>Locked</div>`;
        const ready = performance.now() >= slot.nextReadyAt;
        const remains = ready ? 'Ready' : `${((slot.nextReadyAt - performance.now()) / 1000).toFixed(1)}s`;
        return `<div class="hotkey-slot ${ready ? 'ready' : 'cooling'}">${ABILITY_META[slot.id].key} · ${ABILITY_META[slot.id].name}<br>Lv ${slot.level} · ${slot.charges}/${slot.maxCharges}<br>${remains}</div>`;
      }).join('');

      hpFill.style.width = `${(p.hp/p.maxHp)*100}%`;
      xpFill.style.width = `${(state.xp/state.xpToLevel)*100}%`;
      const shapeTag = state.levelDef?.wallPattern === 'shape' && state.shapeName ? ` · ${state.shapeName}` : '';
      stats.textContent = `Lv ${state.level} · ${fmtTime(state.timeSec)} · ${state.levelDef?.name || ''}${shapeTag} · ${getWeaponDrop(state.activeWeapon).name} · KOs ${state.kills}`;
    }

    let last = performance.now();
    function loop(){
      const now = performance.now();
      const dt = Math.min(0.05, (now-last)/1000);
      last = now;
      if(state.paused) return;
      state.timeSec += dt;
      maybeAdvanceLevel();

      inputLogic(dt);
      spawnLogic();
      whipTick(dt);
      garlicTick(dt);
      batsTick(dt);
      cloneLogic(dt);
      bulletLogic(dt);
      enemyLogic(dt);
      fxLogic(dt);
      pickupGems();
      render();

      if(state.player.hp <= 0){
        state.paused = true;
        overlay.style.display = 'grid';
        choices.innerHTML = `<div>Game Over. KOs: ${state.kills}. Refresh to retry.</div>`;
      }
    }

    boot().catch(err => {
      screen.textContent = 'Failed to load JSON files. Serve files over HTTP (not file://).\n' + err.message;
    });
  </script>
</body>
</html>
