<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ASCII Survivors</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --fg: #f7f7f7;
      --muted: #91a0b8;
      --panel: #111522;
      --accent: #6ae3ff;
      --hp: #ff5c5c;
      --xp: #89ff8f;
      --player: #73f0ff;
      --enemy: #ff6f7d;
      --bullet: #ffd166;
      --pickup: #6cff8d;
      --gem: #7dff95;
      --aura: #d4ff7a;
      --bat: #bda6ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: var(--bg);
      color: var(--fg);
      touch-action: none;
      overscroll-behavior: none;
      user-select: none;
    }
    .app {
      height: 100svh;
      display: grid;
      grid-template-rows: auto minmax(0, 1fr) auto auto;
      gap: 8px;
      padding: max(10px, env(safe-area-inset-top)) 10px max(14px, env(safe-area-inset-bottom));
      overflow: clip;
    }
    .hud {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      font-size: 14px;
    }
    .door-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-top: 4px;
    }
    .safehouse-controls {
      display: none;
      gap: 6px;
      align-items: center;
    }
    .safehouse-controls button { padding: 6px 8px; }
    .bar {
      height: 10px;
      background: #1d2436;
      border-radius: 999px;
      overflow: hidden;
      margin-top: 4px;
    }
    .fill { height: 100%; }
    .hp-fill { background: var(--hp); }
    .xp-fill { background: var(--xp); }
    .shield-fill { background: #53b7ff; }
    .death-note {
      margin-top: 4px;
      min-height: 1.2em;
      color: #9ecbff;
      font-size: 12px;
    }
    .screen-wrap {
      position: relative;
      min-height: 0;
    }
    .play-layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 8px;
      height: 100%;
      min-height: 0;
    }
    .play-layout.shop-open {
      grid-template-columns: minmax(0, 1fr) minmax(170px, 33%);
    }
    #screen {
      margin: 0;
      background: #080b12;
      border: 1px solid #1e2a44;
      border-radius: 10px;
      font-size: min(clamp(14px, 2.6vw, 20px), calc((100vw - 24px) / 34));
      line-height: 1;
      letter-spacing: 0.02em;
      padding: 8px;
      white-space: pre;
      overflow: hidden;
      color: #dbe8ff;
      height: 100%;
      min-height: 0;
    }
    .shop-panel {
      display: none;
      border: 1px solid #2a3552;
      border-radius: 10px;
      background: #0d1322;
      padding: 8px;
      overflow-y: auto;
      min-height: 0;
    }
    .shop-panel h3 { margin: 0 0 8px; font-size: 14px; }
    .shop-choices { display: grid; gap: 8px; }
    @media (max-width: 760px) {
      .app { gap: 6px; padding-inline: 8px; }
      .controls { grid-template-columns: 1fr 1fr; }
      #aimStick { justify-self: end; }
      .stick { width: min(30vw, 120px); }
      #screen { font-size: min(clamp(12px, 3.1vw, 17px), calc((100vw - 20px) / 34)); }
      .play-layout.shop-open { grid-template-columns: minmax(0, 1fr) minmax(140px, 40%); }
      .safehouse-controls button { padding: 5px 7px; }
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      align-items: end;
      gap: 10px;
    }
    .hotbar {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) auto;
      gap: 6px;
      margin: 4px 0;
      align-items: stretch;
    }
    .nav-btn { min-width: 42px; }
    .hotkey-slot {
      border: 1px solid #2a3552;
      border-radius: 8px;
      background: #0d1322;
      color: #b9c7ec;
      font-size: 12px;
      padding: 6px;
      min-height: 56px;
      display: grid;
      gap: 2px;
      align-content: center;
      text-align: center;
      width: 100%;
      cursor: pointer;
    }
    .hotkey-slot.ready { border-color: #70d890; color: #c8ffd7; }
    .hotkey-slot.cooling { border-color: #7d83b7; color: #9fa8d8; }
    .hotkey-slot.empty { opacity: 0.7; }
    .stick {
      width: min(34vw, 148px);
      aspect-ratio: 1;
      border: 2px solid #2a3452;
      border-radius: 50%;
      position: relative;
      background: radial-gradient(circle at center, #12192b 0%, #0d1220 70%);
    }
    .knob {
      width: 44%;
      aspect-ratio: 1;
      border-radius: 50%;
      background: #6a7fb4;
      opacity: 0.85;
      position: absolute;
      left: 28%;
      top: 28%;
      pointer-events: none;
    }
    button, label {
      font: inherit;
      color: var(--fg);
      background: var(--panel);
      border: 1px solid #2a3552;
      border-radius: 8px;
      padding: 8px 10px;
    }
    button:active { transform: scale(0.97); }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(2,5,10,0.88);
      display: none;
      place-items: center;
      z-index: 10;
      padding: 16px;
    }
    .card {
      max-width: 720px;
      width: 100%;
      border: 1px solid #2d3f6d;
      background: #0e1424;
      border-radius: 12px;
      padding: 12px;
    }
    .choices { display: grid; gap: 8px; }
    .choice { width: 100%; text-align: left; border-left: 4px solid var(--accent); }
    .glyph { display: inline-block; }
  </style>
</head>
<body>
  <div class="app">
    <div class="hud">
      <div>
        <div>HP</div>
        <div class="bar"><div id="shieldFill" class="fill shield-fill" style="width:0%"></div></div>
        <div class="bar"><div id="hpFill" class="fill hp-fill" style="width:100%"></div></div>
        <div id="deathNote" class="death-note"></div>
        <div class="door-row">
          <span>Door</span>
          <div id="safehouseControls" class="safehouse-controls">
            <button id="levelPrev" type="button">⬆ Level</button>
            <button id="levelNext" type="button">⬇ Level</button>
            <button id="shopBtn" type="button">Crate Shop ▶</button>
          </div>
        </div>
        <div class="bar"><div id="xpFill" class="fill xp-fill" style="width:0%"></div></div>
      </div>
      <div id="stats">$0 · 00:00 · KOs 0</div>
    </div>

    <div class="screen-wrap">
      <div id="playLayout" class="play-layout">
        <pre id="screen"></pre>
        <aside id="shopPanel" class="shop-panel">
          <h3>Crate Shop</h3>
          <div id="shopChoices" class="shop-choices"></div>
        </aside>
      </div>
    </div>

    <div id="hotbar" class="hotbar">
      <button id="abilityPrev" class="nav-btn" type="button">◀</button>
      <button id="abilitySlot" class="hotkey-slot" type="button"></button>
      <button id="abilityNext" class="nav-btn" type="button">▶</button>
    </div>

    <div class="controls">
      <div id="moveStick" class="stick"><div class="knob"></div></div>
      <div id="aimStick" class="stick"><div class="knob"></div></div>
    </div>
  </div>

  <div id="upgradeOverlay" class="overlay">
    <div class="card">
      <h3>Level Up — choose 1</h3>
      <div id="choices" class="choices"></div>
    </div>
  </div>

  <script>
    const GRID_W = 34, GRID_H = 30;
    const BASE_PLAYER = {
      hp: 30, maxHp: 30, moveSpeed: 5.4, damage: 1, pickupRadius: 1.8, cooldownMs: 520,
      whipLevel: 0, garlicLevel: 0, stakesLevel: 1, batsLevel: 0
    };

    const state = {
      timeSec: 0,
      kills: 0,
      paused: false,
      level: 1,
      money: 0,
      room: 'run',
      highestUnlockedLevel: 1,
      selectedLevelIndex: 0,
      doorTouchSec: 0,
      doorTarget: null,
      player: {
        x: 0, y: 0,
        hp: BASE_PLAYER.hp, maxHp: BASE_PLAYER.maxHp,
        shield: 0, maxShield: 0,
        moveSpeed: BASE_PLAYER.moveSpeed,
        damage: BASE_PLAYER.damage,
        pickupRadius: BASE_PLAYER.pickupRadius,
        cooldownMs: BASE_PLAYER.cooldownMs,
        lastShot: 0,
        aimX: 1, aimY: 0,
        whipLevel: BASE_PLAYER.whipLevel,
        garlicLevel: BASE_PLAYER.garlicLevel,
        stakesLevel: BASE_PLAYER.stakesLevel,
        batsLevel: BASE_PLAYER.batsLevel,
      },
      enemies: [], bullets: [], gems: [], pickups: [], fx: [], clones: [],
      activeWeapon: 'rifle',
      selectedStartWeapon: 'rifle',
      configs: { upgrades: [], enemyTypes: [], waves: [], levels: [] },
      levelDef: null,
      nextSpawnAt: 0,
      nextBossAt: 0,
      joysticks: {
        move: { x:0, y:0, active:false },
        aim:  { x:1, y:0, active:false }
      },
      walls: [],
      flowField: [],
      nextFlowUpdate: 0,
      levelStartTime: 0,
      levelIndex: 0,
      shapeName: '',
      movement: { vx: 0, vy: 0 },
      abilitySlots: [],
      abilityOrder: ['teleportStep', 'sentinelClone', 'graveWall', 'sprintBurst', 'novaBlast', 'bladeWhirl', 'dashRampage', 'glueTrap', 'downgradeHex', 'dualWield', 'voidLance', 'meteorCall', 'timeBubble'],
      phaseWalkUntil: 0,
      entityScale: 1,
      upgradeLevels: {},
      hotbarBound: false,
      selectedAbilityIndex: 0,
      shopOpen: false,
      fixtures: { armorStand: false, gunRack: false, perkMachine: false },
      deathNote: '',
      effects: {
        sprintUntil: 0,
        spinUntil: 0,
        rampageUntil: 0,
        dualWieldUntil: 0,
        timeBubbleUntil: 0
      },
      traps: [],
      activeLances: []
    };

    const screen = document.getElementById('screen');
    const hotbar = document.getElementById('hotbar');
    const abilitySlotBtn = document.getElementById('abilitySlot');
    const shieldFill = document.getElementById('shieldFill');
    const hpFill = document.getElementById('hpFill');
    const xpFill = document.getElementById('xpFill');
    const stats = document.getElementById('stats');
    const deathNote = document.getElementById('deathNote');
    const overlay = document.getElementById('upgradeOverlay');
    const choices = document.getElementById('choices');
    const safehouseControls = document.getElementById('safehouseControls');
    const shopBtn = document.getElementById('shopBtn');
    const playLayout = document.getElementById('playLayout');
    const shopPanel = document.getElementById('shopPanel');
    const shopChoices = document.getElementById('shopChoices');

    function fmtTime(s){ const m = Math.floor(s/60); const r = Math.floor(s%60); return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`; }

    const UPGRADE_COLORS = {
      weapon: '#ff8fab',
      gothic: '#d787ff',
      alchemy: '#7af1a4',
      wasteland: '#ffd166',
      relic: '#8bd3ff',
      ritual: '#ff9a76'
    };


    const WEAPON_DROPS = [
      { id: 'rifle', name: 'Rifle', glyph: 'R', color: '#ffd166', cooldownMult: 1, damageMult: 1, speed: 11, life: 0.9, pierce: 0, spread: 0, projectiles: 1, ricochet: false },
      { id: 'machineGun', name: 'Machine Gun', glyph: 'M', color: '#9ae7ff', cooldownMult: 0.5, damageMult: 0.65, speed: 12, life: 0.8, pierce: 0, spread: 0.04, projectiles: 1, ricochet: false },
      { id: 'laser', name: 'Laser', glyph: 'L', color: '#ff7aff', cooldownMult: 2.1, damageMult: 3.8, speed: 14.5, life: 1.1, pierce: 999, spread: 0, projectiles: 1, ricochet: false },
      { id: 'shotgun', name: 'Shotgun', glyph: 'S', color: '#ffb347', cooldownMult: 1.45, damageMult: 0.8, speed: 10.4, life: 0.55, pierce: 0, spread: 0.24, projectiles: 4, ricochet: false }
    ];

    const AUTO_AIM_ENABLED = true;
    const AUTO_FIRE_ENABLED = true;

    const ABILITY_META = {
      teleportStep: { id: 'teleportStep', key: '1', name: 'Mist Step', desc: 'Teleport in the direction you are moving.', baseCooldown: 9500, maxLevel: 5, baseCharges: 1 },
      sentinelClone: { id: 'sentinelClone', key: '2', name: 'Pale Doppel', desc: 'Place a static clone that shoots nearby enemies.', baseCooldown: 13000, maxLevel: 5, baseCharges: 1 },
      graveWall: { id: 'graveWall', key: '3', name: 'Bone Rampart', desc: 'Build a wall trail where you walk for 5s.', baseCooldown: 15000, maxLevel: 5, baseCharges: 1 },
      sprintBurst: { id: 'sprintBurst', key: '4', name: 'Wolf Sprint', desc: 'Sprint for 6 seconds and phase through crowds.', baseCooldown: 20000, maxLevel: 5, baseCharges: 1 },
      novaBlast: { id: 'novaBlast', key: '5', name: 'Cataclysm Nova', desc: 'Explode outward for huge area damage.', baseCooldown: 14000, maxLevel: 5, baseCharges: 1 },
      bladeWhirl: { id: 'bladeWhirl', key: '6', name: 'Blade Cyclone', desc: 'Spin in place and shred everything nearby.', baseCooldown: 12000, maxLevel: 5, baseCharges: 1 },
      dashRampage: { id: 'dashRampage', key: '7', name: 'Dash Rampage', desc: 'Chain violent dashes through enemy lines.', baseCooldown: 12500, maxLevel: 5, baseCharges: 1 },
      glueTrap: { id: 'glueTrap', key: '8', name: 'Glue Mire', desc: 'Throw sticky traps that slow and hurt enemies.', baseCooldown: 9000, maxLevel: 5, baseCharges: 2 },
      downgradeHex: { id: 'downgradeHex', key: '9', name: 'Regression Hex', desc: 'Downgrade nearby enemy classes by one tier.', baseCooldown: 17000, maxLevel: 5, baseCharges: 1 },
      dualWield: { id: 'dualWield', key: '0', name: 'Twin Relics', desc: 'Fire two weapons at once for 7 seconds.', baseCooldown: 18000, maxLevel: 5, baseCharges: 1 },
      voidLance: { id: 'voidLance', key: 'Q', name: 'Void Lance', desc: 'Summon piercing lances around your aim line.', baseCooldown: 11000, maxLevel: 5, baseCharges: 1 },
      meteorCall: { id: 'meteorCall', key: 'E', name: 'Meteor Psalm', desc: 'Call meteors to strike random enemy packs.', baseCooldown: 14500, maxLevel: 5, baseCharges: 1 },
      timeBubble: { id: 'timeBubble', key: 'R', name: 'Chrono Bubble', desc: 'Slow all enemies and hasten your fire rate.', baseCooldown: 16000, maxLevel: 5, baseCharges: 1 }
    };

    function escapeHtml(ch){
      if(ch === '&') return '&amp;';
      if(ch === '<') return '&lt;';
      if(ch === '>') return '&gt;';
      return ch;
    }

    function setCell(glyphs, x, y, char, color){
      if(x<0||y<0||x>=GRID_W||y>=GRID_H) return;
      glyphs[y][x] = { char, color };
    }

    function upgradeColor(up){
      if(up.theme && UPGRADE_COLORS[up.theme]) return UPGRADE_COLORS[up.theme];
      if(['whip','stakes','bats'].includes(up.id)) return UPGRADE_COLORS.weapon;
      if(['garlic'].includes(up.id)) return UPGRADE_COLORS.alchemy;
      if(['damage','fireRate'].includes(up.id)) return UPGRADE_COLORS.wasteland;
      return UPGRADE_COLORS.relic;
    }
    function rand(a,b){ return Math.random()*(b-a)+a; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    function normalize(x,y){ const d=Math.hypot(x,y)||1; return {x:x/d, y:y/d}; }

    const SAVE_KEY = 'ascii-survivors-save-v2';

    function loadPersistentState(){
      try{
        const raw = localStorage.getItem(SAVE_KEY);
        if(!raw) return;
        const save = JSON.parse(raw);
        state.fixtures.armorStand = !!save.fixtures?.armorStand;
        state.fixtures.gunRack = !!save.fixtures?.gunRack;
        state.fixtures.perkMachine = !!save.fixtures?.perkMachine;
        if(save.selectedStartWeapon && WEAPON_DROPS.some(w=>w.id===save.selectedStartWeapon)) state.selectedStartWeapon = save.selectedStartWeapon;
      }catch(_err){}
    }

    function savePersistentState(){
      const payload = { fixtures: state.fixtures, selectedStartWeapon: state.selectedStartWeapon };
      localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
    }

    async function loadJson(path){ const r = await fetch(path); if(!r.ok) throw new Error(`Missing ${path}`); return r.json(); }
    async function boot(){
      loadPersistentState();
      state.configs.upgrades = await loadJson('./upgrades.json');
      state.configs.enemyTypes = await loadJson('./enemy-types.json');
      state.configs.waves = await loadJson('./waves.json');
      state.configs.levels = await loadJson('./levels.json');
      state.levelDef = state.configs.levels[0];
      state.levelStartTime = 0;
      state.nextBossAt = state.levelDef.bossIntervalSec;
      resetPlayer();
      setupSafehouse();
      bindStick('moveStick', 'move');
      bindStick('aimStick', 'aim');
      initAbilitySlots();
      rebuildFromUpgrades();
      bindHotkeys();
      bindAbilityNavigator();
      bindSafehouseControls();
      requestAnimationFrame(loop);
    }

    function initAbilitySlots(){
      state.abilitySlots = state.abilityOrder.map(id => ({
        id,
        level: 0,
        charges: 0,
        maxCharges: ABILITY_META[id].baseCharges,
        cooldownMs: ABILITY_META[id].baseCooldown,
        nextReadyAt: 0
      }));
    }

    function bindHotkeys(){
      window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowLeft') selectAbility(-1);
        if(e.key === 'ArrowRight') selectAbility(1);
        if(e.key === ' ') activateSelectedAbility();
      });
    }

    function bindAbilityNavigator(){
      document.getElementById('abilityPrev').addEventListener('click', () => selectAbility(-1));
      document.getElementById('abilityNext').addEventListener('click', () => selectAbility(1));
      abilitySlotBtn.addEventListener('click', activateSelectedAbility);
    }

    function selectAbility(dir){
      if(!state.abilitySlots.length) return;
      const len = state.abilitySlots.length;
      state.selectedAbilityIndex = (state.selectedAbilityIndex + dir + len) % len;
    }

    function activateSelectedAbility(){
      activateAbilitySlot(state.selectedAbilityIndex);
    }

    function resetPlayer(){ state.player.x = GRID_W/2; state.player.y = GRID_H/2; }

    function bindSafehouseControls(){
      document.getElementById('levelPrev').addEventListener('click', ()=>{
        state.selectedLevelIndex = clamp(state.selectedLevelIndex + 1, 0, state.highestUnlockedLevel - 1);
      });
      document.getElementById('levelNext').addEventListener('click', ()=>{
        state.selectedLevelIndex = clamp(state.selectedLevelIndex - 1, 0, state.highestUnlockedLevel - 1);
      });
      document.getElementById('shopBtn').addEventListener('click', openCrateShop);
    }

    function cellBlocked(x, y){
      if(x < 0 || y < 0 || x >= GRID_W || y >= GRID_H) return true;
      return (state.walls[y]?.[x] || 0) > 0;
    }

    function randomOpenCell(){
      for(let i=0;i<300;i++){
        const x = Math.floor(rand(1, GRID_W - 1));
        const y = Math.floor(rand(1, GRID_H - 1));
        if(!cellBlocked(x, y)) return {x: x + 0.5, y: y + 0.5};
      }
      return {x: GRID_W / 2, y: GRID_H / 2};
    }

    function buildMaze(){
      const walls = Array.from({length: GRID_H}, (_, y) => Array.from({length: GRID_W}, (_, x) => x % 2 === 0 || y % 2 === 0 ? 7 : 0));
      const visited = Array.from({length: GRID_H}, () => Array(GRID_W).fill(false));
      const stack = [{x: 1, y: 1}];
      visited[1][1] = true;
      walls[1][1] = 0;
      const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
      while(stack.length){
        const cur = stack[stack.length - 1];
        const moves = dirs
          .map(([dx,dy])=>({x:cur.x+dx,y:cur.y+dy,dx,dy}))
          .filter(n => n.x > 0 && n.y > 0 && n.x < GRID_W - 1 && n.y < GRID_H - 1 && !visited[n.y][n.x]);
        if(!moves.length){ stack.pop(); continue; }
        const pick = moves[Math.floor(Math.random() * moves.length)];
        visited[pick.y][pick.x] = true;
        walls[cur.y + pick.dy / 2][cur.x + pick.dx / 2] = 0;
        walls[pick.y][pick.x] = 0;
        stack.push({x: pick.x, y: pick.y});
      }
      return walls;
    }

    function emptyWallGrid(){ return Array.from({length: GRID_H}, () => Array(GRID_W).fill(0)); }
    function paintCell(walls, x, y, hp = 7){ if(x>=1&&y>=1&&x<GRID_W-1&&y<GRID_H-1) walls[y][x] = hp; }

    function carveShape(shape){
      const walls = emptyWallGrid();
      const cx = Math.floor(GRID_W / 2), cy = Math.floor(GRID_H / 2);
      if(shape === 'skull'){
        for(let y=2;y<GRID_H-3;y++) for(let x=5;x<GRID_W-5;x++){
          const dx = (x-cx)/15, dy = (y-(cy-2))/9;
          if(dx*dx + dy*dy < 1) paintCell(walls, x, y, 8);
        }
        for(let y=cy-5;y<=cy-2;y++) for(const x of [cx-6,cx-5,cx+5,cx+6]) walls[y][x] = 0;
        for(let y=cy+2;y<cy+8;y++) for(let x=cx-7;x<=cx+7;x++) if((x+y)%3!==0) paintCell(walls, x, y, 6);
      }
      if(shape === 'sword'){
        for(let y=4;y<GRID_H-5;y++) for(let x=cx-1;x<=cx+1;x++) paintCell(walls, x, y, 8);
        for(let i=0;i<6;i++) for(let x=cx-3+i;x<=cx+3-i;x++) paintCell(walls, x, 3+i, 8);
        for(let x=cx-5;x<=cx+5;x++) paintCell(walls, x, GRID_H-6, 7);
        for(let y=GRID_H-5;y<GRID_H-2;y++) for(let x=cx-2;x<=cx+2;x++) paintCell(walls, x, y, 7);
      }
      if(shape === 'potion'){
        for(let y=4;y<9;y++) for(let x=cx-2;x<=cx+2;x++) paintCell(walls, x, y, 7);
        for(let y=8;y<GRID_H-4;y++) for(let x=6;x<GRID_W-6;x++){
          const dx=(x-cx)/14, dy=(y-(cy+2))/9;
          if(dx*dx + dy*dy < 1) paintCell(walls, x, y, 7);
        }
      }
      if(shape === 'shield'){
        for(let y=3;y<GRID_H-3;y++) for(let x=6;x<GRID_W-6;x++){
          const dx=(x-cx)/14, dy=(y-(cy-2))/10;
          if(dx*dx + dy*dy < 1.05 && y < cy+6-Math.abs(dx*3)) paintCell(walls, x, y, 8);
        }
      }
      if(shape === 'tree'){
        for(let y=5;y<cy+5;y++) for(let x=8;x<GRID_W-8;x++){
          const dx=(x-cx)/(15-(y-5)*0.4), dy=(y-(cy-2))/10;
          if(dx*dx + dy*dy < 1) paintCell(walls, x, y, 6);
        }
        for(let y=cy+4;y<GRID_H-2;y++) for(let x=cx-2;x<=cx+2;x++) paintCell(walls, x, y, 9);
      }
      if(shape === 'mountain'){
        for(let y=4;y<GRID_H-2;y++){
          const width = Math.floor((y-3) * 1.25);
          for(let x=cx-width; x<=cx+width; x++) if(Math.random() > 0.08 || y > cy+4) paintCell(walls, x, y, 8);
        }
      }
      return walls;
    }

    function generateWalls(){
      state.shapeName = '';
      return emptyWallGrid();
    }

    function rebuildLevelGeometry(){
      state.walls = generateWalls();
      enforceBorderWalls();
      const spawn = randomOpenCell();
      state.player.x = spawn.x;
      state.player.y = spawn.y;
      clearSpawnArea(spawn.x, spawn.y, 2.2);
      state.flowField = [];
      state.nextFlowUpdate = 0;
      state.movement.vx = 0;
      state.movement.vy = 0;
      state.walls[GRID_H - 2][Math.floor(GRID_W / 2)] = 0;
      clearSpawnArea(GRID_W / 2, GRID_H - 2, 2);
    }

    function enforceBorderWalls(){
      for(let x=0;x<GRID_W;x++){
        state.walls[0][x] = 9;
        state.walls[GRID_H-1][x] = 9;
      }
      for(let y=0;y<GRID_H;y++){
        state.walls[y][0] = 9;
        state.walls[y][GRID_W-1] = 9;
      }
    }

    function clearSpawnArea(x, y, radius = 2){
      for(let gy=Math.floor(y-radius); gy<=Math.ceil(y+radius); gy++){
        for(let gx=Math.floor(x-radius); gx<=Math.ceil(x+radius); gx++){
          if(gx <= 0 || gy <= 0 || gx >= GRID_W - 1 || gy >= GRID_H - 1) continue;
          if(Math.hypot(gx + 0.5 - x, gy + 0.5 - y) <= radius + 0.4) state.walls[gy][gx] = 0;
        }
      }
    }

    function setupSafehouse(){
      state.room = 'safehouse';
      state.shopOpen = false;
      state.walls = emptyWallGrid();
      enforceBorderWalls();
      state.player.x = GRID_W / 2;
      state.player.y = GRID_H - 4;
      state.walls[1][Math.floor(GRID_W / 2)] = 0;
      state.enemies = []; state.bullets = []; state.gems = []; state.pickups = [];
      state.doorTouchSec = 0;
    }

    function startRun(){
      state.room = 'run';
      state.shopOpen = false;
      state.levelDef = state.configs.levels[state.selectedLevelIndex] || state.configs.levels[0];
      state.levelStartTime = 0;
      state.timeSec = 0;
      state.nextBossAt = state.levelDef.bossIntervalSec;
      state.kills = 0;
      state.enemies = []; state.bullets = []; state.gems = []; state.pickups = [];
      state.activeWeapon = state.fixtures.gunRack ? state.selectedStartWeapon : 'rifle';
      state.player.shield = state.player.maxShield;
      state.deathNote = '';
      rebuildLevelGeometry();
      state.doorTouchSec = 0;
    }

    function updateFlowField(){
      const tx = clamp(Math.floor(state.player.x), 0, GRID_W - 1);
      const ty = clamp(Math.floor(state.player.y), 0, GRID_H - 1);
      const flow = Array.from({length: GRID_H}, () => Array(GRID_W).fill(Infinity));
      const queue = [{x: tx, y: ty}];
      flow[ty][tx] = 0;
      for(let i=0;i<queue.length;i++){
        const c = queue[i], base = flow[c.y][c.x] + 1;
        for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx = c.x + dx, ny = c.y + dy;
          if(nx < 0 || ny < 0 || nx >= GRID_W || ny >= GRID_H || cellBlocked(nx, ny)) continue;
          if(base < flow[ny][nx]){ flow[ny][nx] = base; queue.push({x:nx,y:ny}); }
        }
      }
      state.flowField = flow;
    }

    function bindStick(id, key){
      const el = document.getElementById(id), knob = el.querySelector('.knob');
      const joy = state.joysticks[key];
      function update(clientX, clientY){
        const rect = el.getBoundingClientRect();
        const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
        let dx = (clientX - cx) / (rect.width/2), dy = (clientY - cy) / (rect.height/2);
        const mag = Math.hypot(dx,dy); if(mag > 1){ dx/=mag; dy/=mag; }
        joy.x = dx; joy.y = dy;
        knob.style.left = `${28 + dx * 26}%`;
        knob.style.top = `${28 + dy * 26}%`;
      }
      function clear(){ joy.x=0; joy.y=0; joy.active=false; knob.style.left='28%'; knob.style.top='28%'; }
      el.addEventListener('pointerdown', e=>{ joy.active=true; update(e.clientX,e.clientY); el.setPointerCapture(e.pointerId); });
      el.addEventListener('pointermove', e=> joy.active && update(e.clientX,e.clientY));
      el.addEventListener('pointerup', clear);
      el.addEventListener('pointercancel', clear);
    }

    function getEnemyType(id){ return state.configs.enemyTypes.find(e => e.id === id); }
    function getWeaponDrop(id){ return WEAPON_DROPS.find(w => w.id === id) || WEAPON_DROPS[0]; }
    function randomWeaponDrop(){ return WEAPON_DROPS[Math.floor(Math.random() * WEAPON_DROPS.length)]; }
    function pickWeighted(mix){
      const total = mix.reduce((s,m)=>s+m.weight,0); let roll = Math.random()*total;
      for(const m of mix){ roll -= m.weight; if(roll <= 0) return m.type; }
      return mix[0].type;
    }

    function currentWave(){
      const t = state.timeSec;
      return state.configs.waves.find(w => t >= w.startSec && t < w.endSec) || state.configs.waves[state.configs.waves.length-1];
    }

    function spawnEnemy(typeId){
      const t = getEnemyType(typeId); if(!t) return;
      let x=0,y=0;
      for(let i=0;i<40;i++){
        const side = Math.floor(Math.random()*4);
        if(side===0){ x=rand(0,GRID_W); y=1; }
        if(side===1){ x=GRID_W-2; y=rand(0,GRID_H); }
        if(side===2){ x=rand(0,GRID_W); y=GRID_H-2; }
        if(side===3){ x=1; y=rand(0,GRID_H); }
        if(!cellBlocked(Math.floor(x), Math.floor(y))) break;
      }
      state.enemies.push({
        x,y,type:t.id,char:t.char,color:t.color,
        hp:t.hp + state.timeSec*0.05,
        speed:t.speed*1.2,
        touchDamage:t.touchDamage,
        xp:t.xp,
        boss: !!t.boss,
        hitFlash:0,
        size: t.size || 1,
        canBreakWalls: t.canBreakWalls !== false,
        wallDamage: t.wallDamage || 0.6,
        dashWindup: 0,
        dashCooldown: 0,
        dashDirX: 0,
        dashDirY: 0,
        dashing: 0,
        wallHitTicks: 0
      });
    }

    function breakWallTowardEntity(entity, tx, ty, dt){
      const nx = normalize(tx - entity.x, ty - entity.y);
      const wx = entity.x + nx.x * 0.8;
      const wy = entity.y + nx.y * 0.8;
      const damage = Math.max(0.1, entity.wallDamage * dt * 10);
      return damageWallAt(wx, wy, damage);
    }

    function spawnParticles(kind, x, y, amount){
      const configs = {
        blood: { chars: ['.'], colors: ['#ff3b3b', '#ff4a4a', '#ff5a5a'], speed: [2.2, 5.3], life: [0.22, 0.55] },
        blast: { chars: ['+', '*', 'x', ':'], colors: ['#ffd166', '#ff9f40', '#ff6b35'], speed: [0.8, 2.6], life: [0.15, 0.55] }
      };
      const cfg = configs[kind];
      if(!cfg) return;
      for(let i=0;i<amount;i++){
        const a = Math.random() * Math.PI * 2;
        const speed = rand(cfg.speed[0], cfg.speed[1]);
        state.fx.push({
          x,
          y,
          vx: Math.cos(a) * speed,
          vy: Math.sin(a) * speed,
          life: rand(cfg.life[0], cfg.life[1]),
          char: cfg.chars[Math.floor(Math.random() * cfg.chars.length)],
          color: cfg.colors[Math.floor(Math.random() * cfg.colors.length)]
        });
      }
    }

    function fxLogic(dt){
      for(let i=state.fx.length-1;i>=0;i--){
        const f = state.fx[i];
        f.life -= dt;
        f.x += f.vx * dt;
        f.y += f.vy * dt;
        f.vx *= 0.9;
        f.vy *= 0.9;
        if(f.life <= 0) state.fx.splice(i, 1);
      }
    }

    function fire(){
      const p = state.player;
      const now = performance.now();
      const canFire = AUTO_FIRE_ENABLED || state.joysticks.aim.active;
      const weapon = getWeaponDrop(state.activeWeapon);
      const bubbleHaste = state.effects.timeBubbleUntil > state.timeSec ? 0.65 : 1;
      const cooldown = Math.max(90, p.cooldownMs * weapon.cooldownMult * bubbleHaste);
      if(!canFire || now - p.lastShot < cooldown) return;
      p.lastShot = now;
      const aim = normalize(p.aimX, p.aimY);
      const weaponSpread = weapon.spread || 0;
      const upgradeSpread = p.stakesLevel >= 3 ? 0.07 : 0;
      const spread = weaponSpread + upgradeSpread;
      const weaponCount = weapon.id === 'shotgun' ? (Math.random() < 0.5 ? 3 : 4) : weapon.projectiles;
      const count = Math.max(1, weaponCount + (p.stakesLevel >= 5 ? 1 : 0));
      const fireWeapon = (w, aimOffset = 0) => {
        for(let i=0;i<count;i++){
          const t = count === 1 ? 0 : (i / (count - 1)) * 2 - 1;
          const a = Math.atan2(aim.y, aim.x) + t * spread + aimOffset;
          const crit = Math.random() < (p.critChance || 0);
          const dmgBase = (2 + p.damage + p.stakesLevel * 0.45) * w.damageMult;
          state.bullets.push({
            x:p.x, y:p.y,
            vx:Math.cos(a)*(w.speed + p.stakesLevel * 0.4), vy:Math.sin(a)*(w.speed + p.stakesLevel * 0.4),
            dmg:crit ? dmgBase * (p.critMult || 1.6) : dmgBase,
            life:w.life,
            pierce: w.pierce + Math.floor(p.stakesLevel/2),
            ricochet: p.stakesLevel >= 4 ? 1 : 0,
            char: w.id === 'laser' ? '=' : (p.stakesLevel >= 4 ? '*' : '.')
          });
        }
      };
      fireWeapon(weapon);
      if(state.effects.dualWieldUntil > state.timeSec){
        const alt = WEAPON_DROPS.find(w => w.id !== weapon.id) || weapon;
        fireWeapon(alt, 0.08);
      }
    }

    function whipTick(dt){
      const p = state.player;
      if(p.whipLevel <= 0) return;
      if(Math.random() > dt * (0.7 + p.whipLevel*0.2)) return;
      const arc = Math.PI * (0.35 + p.whipLevel * 0.04);
      const forward = Math.atan2(p.aimY,p.aimX);
      for(const e of state.enemies){
        const d = dist(p,e); if(d > 3.8 + p.whipLevel*0.25) continue;
        const a = Math.atan2(e.y-p.y,e.x-p.x);
        let diff = Math.abs(a-forward); if(diff > Math.PI) diff = 2*Math.PI - diff;
        if(diff <= arc/2){
          e.hp -= 3 + p.damage + p.whipLevel;
          const n = normalize(e.x-p.x,e.y-p.y);
          e.x += n.x*(0.5 + p.whipLevel*0.08);
          e.y += n.y*(0.5 + p.whipLevel*0.08);
          e.hitFlash = 0.15;
        }
      }
    }

    function garlicTick(dt){
      const p = state.player;
      if(p.garlicLevel <= 0) return;
      const r = 1.2 + p.garlicLevel * 0.45;
      for(const e of state.enemies){
        if(dist(p,e) <= r){ e.hp -= dt * (2 + p.garlicLevel + p.damage*0.4); e.hitFlash = 0.05; }
      }
    }

    function batsTick(dt){
      if(state.player.batsLevel <= 0) return;
      const p = state.player;
      const count = p.batsLevel + 1;
      for(let i=0;i<count;i++){
        const a = state.timeSec*2.2 + (Math.PI*2/count)*i;
        const r = 1.8 + p.batsLevel*0.25;
        const bx = p.x + Math.cos(a)*r, by = p.y + Math.sin(a)*r;
        for(const e of state.enemies){
          if(Math.hypot(e.x-bx,e.y-by) < 0.8){
            e.hp -= dt*(7 + p.batsLevel + p.damage*0.4);
            e.hitFlash = 0.05;
          }
        }
      }
    }

    function cloneLogic(dt){
      for(let i=state.clones.length-1;i>=0;i--){
        const c = state.clones[i];
        c.ttl -= dt;
        if(c.ttl <= 0){ state.clones.splice(i,1); continue; }
        let target = null;
        for(const e of state.enemies){
          if(dist(c, e) <= c.range && (!target || dist(c, e) < dist(c, target))) target = e;
        }
        if(target){
          target.hp -= c.dps * dt;
          target.hitFlash = 0.06;
          if(Math.random() < dt * 12) state.fx.push({ x: c.x, y: c.y, vx: (target.x-c.x)*2, vy: (target.y-c.y)*2, life: 0.1, char: '•', color: '#c9d4ff' });
        }
      }
    }

    function downgradeEnemy(e){
      const map = { boss: 'juggernaut', juggernaut: 'wraith', wraith: 'brute', brute: 'batling' };
      const next = map[e.type];
      if(!next) return;
      const t = getEnemyType(next);
      if(!t) return;
      const hpRatio = clamp(e.hp / Math.max(1, getEnemyType(e.type)?.hp || e.hp), 0.2, 1);
      e.type = t.id;
      e.char = t.char;
      e.color = t.color;
      e.hp = Math.max(1, t.hp * hpRatio);
      e.speed = t.speed * 1.2;
      e.touchDamage = t.touchDamage;
      e.xp = t.xp;
      e.size = t.size || 1;
      e.boss = !!t.boss;
      e.wallDamage = t.wallDamage || 0.6;
      e.hitFlash = 0.3;
    }

    function abilityEffectsLogic(dt){
      const p = state.player;
      if(state.effects.spinUntil > state.timeSec){
        const dps = 11 + (state.upgradeLevels.bladeWhirl || 0) * 4;
        for(const e of state.enemies){
          if(dist(p, e) < 1.8){ e.hp -= dps * dt; e.hitFlash = 0.08; }
        }
      }
      if(state.effects.rampageUntil > state.timeSec){
        const dps = 18 + (state.upgradeLevels.dashRampage || 0) * 5;
        for(const e of state.enemies){
          if(dist(p, e) < 1.2){ e.hp -= dps * dt; e.hitFlash = 0.1; }
        }
      }
      for(let i=state.traps.length-1;i>=0;i--){
        const t = state.traps[i];
        t.ttl -= dt;
        if(t.ttl <= 0){ state.traps.splice(i,1); continue; }
        for(const e of state.enemies){
          if(dist(t, e) < t.radius){
            e.slowMul = Math.min(e.slowMul || 1, t.slow);
            e.slowTimer = Math.max(e.slowTimer || 0, 0.2);
            e.hp -= t.dps * dt;
            e.hitFlash = 0.05;
          }
        }
      }
      for(let i=state.activeLances.length-1;i>=0;i--){
        const l = state.activeLances[i];
        l.ttl -= dt;
        if(l.ttl <= 0){ state.activeLances.splice(i,1); continue; }
        for(const e of state.enemies){
          const d = Math.hypot(e.x - l.x, e.y - l.y);
          if(d < 0.9){ e.hp -= l.dps * dt; e.hitFlash = 0.1; }
        }
      }
    }

    function circleBlocked(x, y, radius = 0.3){
      const checks = [
        [x, y],
        [x + radius, y], [x - radius, y],
        [x, y + radius], [x, y - radius],
        [x + radius * 0.7, y + radius * 0.7],
        [x + radius * 0.7, y - radius * 0.7],
        [x - radius * 0.7, y + radius * 0.7],
        [x - radius * 0.7, y - radius * 0.7]
      ];
      return checks.some(([cx, cy]) => cellBlocked(Math.floor(cx), Math.floor(cy)));
    }

    function clampInsideBounds(v, radius, max){
      return clamp(v, 1 + radius, max - 1 - radius - 0.001);
    }

    function directionGlyph(x, y){
      const a = Math.atan2(y, x);
      if(a >= -Math.PI / 8 && a < Math.PI / 8) return '➤';
      if(a >= Math.PI / 8 && a < (3 * Math.PI) / 8) return '↘';
      if(a >= (3 * Math.PI) / 8 && a < (5 * Math.PI) / 8) return '▼';
      if(a >= (5 * Math.PI) / 8 && a < (7 * Math.PI) / 8) return '↙';
      if(a >= (7 * Math.PI) / 8 || a < -(7 * Math.PI) / 8) return '◀';
      if(a >= -(7 * Math.PI) / 8 && a < -(5 * Math.PI) / 8) return '↖';
      if(a >= -(5 * Math.PI) / 8 && a < -(3 * Math.PI) / 8) return '▲';
      return '↗';
    }

    function applyPlayerDamage(amount){
      const p = state.player;
      const reduced = Math.max(0, amount * (1 - (p.armor || 0)));
      let dmg = reduced;
      if((p.shield || 0) > 0){
        const used = Math.min(p.shield, dmg);
        p.shield -= used;
        dmg -= used;
      }
      if(dmg > 0) p.hp -= dmg;
    }

    function enemyLogic(dt){
      const p = state.player;
      for(const e of state.enemies){
        const n = normalize(p.x - e.x, p.y - e.y);
        let moveX = n.x;
        let moveY = n.y;
        e.slowTimer = Math.max(0, (e.slowTimer || 0) - dt);
        const localSlow = e.slowTimer > 0 ? (e.slowMul || 1) : 1;
        const bubbleSlow = state.effects.timeBubbleUntil > state.timeSec ? 0.45 : 1;
        let speed = e.speed * localSlow * bubbleSlow * dt;

        if(e.type === 'juggernaut'){
          e.dashCooldown = Math.max(0, e.dashCooldown - dt);
          e.dashing = Math.max(0, e.dashing - dt);
          if(e.dashing > 0){
            moveX = e.dashDirX;
            moveY = e.dashDirY;
            speed = e.speed * 7.2 * dt;
          } else if(e.dashWindup > 0){
            e.dashWindup -= dt;
            moveX = 0;
            moveY = 0;
            speed = 0;
            if(e.dashWindup <= 0){
              e.dashing = 0.5;
              e.dashCooldown = 2.2;
            }
          } else if(e.dashCooldown <= 0){
            const dir = normalize((p.x + rand(-1, 1)) - e.x, (p.y + rand(-1, 1)) - e.y);
            e.dashDirX = dir.x;
            e.dashDirY = dir.y;
            e.dashWindup = 0.75;
          }
        }

        const radius = 0.3 * (e.size || 1);
        e.x = clampInsideBounds(e.x + moveX * speed, radius, GRID_W);
        e.y = clampInsideBounds(e.y + moveY * speed, radius, GRID_H);

        if(dist(e,p) < 0.65 + (e.size - 1) * 0.45){ applyPlayerDamage(e.touchDamage*dt); }
        e.hitFlash = Math.max(0, e.hitFlash - dt);
      }
      for(let i=state.enemies.length-1;i>=0;i--){
        const e = state.enemies[i];
        if(e.hp <= 0){
          spawnParticles('blood', e.x, e.y, e.boss ? 24 : 12);
          state.kills++;
          state.gems.push({x:e.x,y:e.y,v:Math.max(1, Math.round(e.xp * 2))});
          if(e.boss || Math.random() < 0.1){
            const drop = randomWeaponDrop();
            state.pickups.push({ x: e.x, y: e.y, weaponId: drop.id, bornAt: state.timeSec, ttl: rand(3, 5), blinkAt: 1.6 });
          }
          state.enemies.splice(i,1);
        }
      }
    }

    function damageWallAt(x, y, dmg){
      const gx = clamp(Math.floor(x), 0, GRID_W - 1);
      const gy = clamp(Math.floor(y), 0, GRID_H - 1);
      const hp = state.walls[gy]?.[gx] || 0;
      if(hp <= 0) return false;
      const nextHp = Math.max(0, hp - dmg);
      state.walls[gy][gx] = nextHp;
      if(nextHp <= 0) spawnParticles('blast', gx + 0.5, gy + 0.5, 8);
      return true;
    }

    function bulletLogic(dt){
      for(let i=state.bullets.length-1;i>=0;i--){
        const b = state.bullets[i];
        b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt;
        const hitWall = damageWallAt(b.x, b.y, Math.max(1, b.dmg * 0.9));
        if(b.x<0||b.x>=GRID_W||b.y<0||b.y>=GRID_H||hitWall){
          if(b.ricochet>0){ b.ricochet--; b.vx*=-1; b.vy*=-1; }
          else { state.bullets.splice(i,1); continue; }
        }
        let used = false;
        for(const e of state.enemies){
          if(Math.hypot(e.x-b.x,e.y-b.y) < 0.55){
            e.hp -= b.dmg; e.hitFlash=0.07;
            if(state.player.lifeSteal){ state.player.hp = clamp(state.player.hp + b.dmg * state.player.lifeSteal, 0, state.player.maxHp); }
            if(b.pierce > 0){ b.pierce--; } else { used = true; break; }
          }
        }
        if(used || b.life <= 0) state.bullets.splice(i,1);
      }
    }

    function pickupGems(){
      const p = state.player;
      for(let i=state.gems.length-1;i>=0;i--){
        const g = state.gems[i], d = dist(p,g);
        if(d < p.pickupRadius){
          state.money += g.v;
          state.gems.splice(i,1);
        } else if(d < p.pickupRadius + 2.5){
          const n = normalize(p.x-g.x,p.y-g.y);
          g.x += n.x*0.06; g.y += n.y*0.06;
        }
      }
      for(let i=state.pickups.length-1;i>=0;i--){
        const pickup = state.pickups[i];
        const age = state.timeSec - (pickup.bornAt || 0);
        if(age > (pickup.ttl || 4)){
          state.pickups.splice(i, 1);
          continue;
        }
        if(dist(p, pickup) < 0.9){
          state.activeWeapon = pickup.weaponId;
          state.pickups.splice(i, 1);
        }
      }
    }

    function upgradeCost(up){
      const level = state.upgradeLevels[up.id] || 0;
      return 15 + level * 18;
    }

    function upgradeBucket(up){
      if(up.exclusiveGroup) return up.exclusiveGroup;
      return up.id;
    }

    function pickShopUpgrades(available, count = 4){
      const shuffled = [...available].sort(()=>Math.random()-0.5);
      const picks = [];
      const used = new Set();
      for(const up of shuffled){
        const bucket = upgradeBucket(up);
        if(used.has(bucket)) continue;
        used.add(bucket);
        picks.push(up);
        if(picks.length >= count) break;
      }
      return picks;
    }

    function openCrateShop(){
      if(state.room !== 'safehouse') return;
      state.shopOpen = !state.shopOpen;
      if(!state.shopOpen) return;
      const available = state.configs.upgrades.filter(canTakeUpgrade);
      const picks = pickShopUpgrades(available, 4);
      shopChoices.innerHTML = '';

      const fixtures = [
        { id: 'armorStand', name: 'Armor Stand', desc: 'Permanent: +16 blue shield each run.' },
        { id: 'gunRack', name: 'Gun Rack', desc: `Permanent: start with ${getWeaponDrop(state.selectedStartWeapon).name}.` },
        { id: 'perkMachine', name: 'Perk Machine', desc: 'Permanent: spend $10 for a random upgrade roll.' }
      ];
      for(const fix of fixtures){
        const purchased = state.fixtures[fix.id];
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'choice';
        btn.style.borderLeftColor = purchased ? '#6cff8d' : '#8bd3ff';
        btn.textContent = purchased ? `✔ ${fix.name}: ${fix.desc}` : `${fix.name} ($50): ${fix.desc}`;
        btn.disabled = purchased || state.money < 50;
        btn.addEventListener('click', ()=>{
          if(purchased || state.money < 50) return;
          state.money -= 50;
          state.fixtures[fix.id] = true;
          rebuildFromUpgrades();
          savePersistentState();
          state.shopOpen = false;
        });
        shopChoices.appendChild(btn);
      }

      if(state.fixtures.gunRack){
        const gunWrap = document.createElement('div');
        gunWrap.textContent = 'Gun Rack Loadout:';
        shopChoices.appendChild(gunWrap);
        for(const weapon of WEAPON_DROPS){
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'choice';
          const selected = state.selectedStartWeapon === weapon.id;
          btn.textContent = `${selected ? '▶' : '○'} ${weapon.name}`;
          btn.addEventListener('click', ()=>{
            state.selectedStartWeapon = weapon.id;
            savePersistentState();
            state.shopOpen = false;
            openCrateShop();
          });
          shopChoices.appendChild(btn);
        }
      }

      if(state.fixtures.perkMachine){
        const perkBtn = document.createElement('button');
        perkBtn.type = 'button';
        perkBtn.className = 'choice';
        perkBtn.style.borderLeftColor = '#ffd166';
        perkBtn.textContent = 'Perk Machine ($10): Roll a random upgrade';
        perkBtn.disabled = state.money < 10 || !available.length;
        perkBtn.addEventListener('click', ()=>{
          if(state.money < 10 || !available.length) return;
          state.money -= 10;
          const roll = available[Math.floor(Math.random() * available.length)];
          applyUpgrade(roll);
          state.shopOpen = false;
        });
        shopChoices.appendChild(perkBtn);
      }

      if(!picks.length){
        shopChoices.innerHTML += '<div>Everything is maxed out.</div>';
      }
      for(const up of picks){
        const cost = upgradeCost(up);
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'choice';
        btn.style.borderLeftColor = upgradeColor(up);
        btn.style.color = upgradeColor(up);
        btn.textContent = `${up.name} ($${cost}): ${upgradeSummary(up)}`;
        btn.disabled = state.money < cost;
        const pick = (event) => {
          event.preventDefault();
          if(state.money < cost) return;
          state.money -= cost;
          applyUpgrade(up);
          state.shopOpen = false;
        };
        btn.addEventListener('pointerdown', pick, { passive: false });
        btn.addEventListener('click', pick);
        shopChoices.appendChild(btn);
      }
      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.className = 'choice';
      closeBtn.textContent = 'Close shop';
      closeBtn.addEventListener('click', ()=>{ state.shopOpen = false; });
      shopChoices.appendChild(closeBtn);
    }

    function canTakeUpgrade(up){
      const p = state.player;
      const level = state.upgradeLevels[up.id] || 0;
      if(level >= (up.maxLevel || 99)) return false;
      if(up.id in ABILITY_META){
        const slot = state.abilitySlots.find(s => s.id === up.id);
        return !!slot;
      }
      if(up.id === 'extraAbilityUse') return state.abilitySlots.some(s => s.level > 0 && s.maxCharges < 6);
      const map = { whip: 'whipLevel', garlic: 'garlicLevel', stakes: 'stakesLevel', bats: 'batsLevel' };
      const k = map[up.id];
      if(k) return true;
      return true;
    }

    function applyUpgrade(up){
      const p = state.player;
      state.upgradeLevels[up.id] = (state.upgradeLevels[up.id] || 0) + 1;
      if(up.id in ABILITY_META){
        const slot = state.abilitySlots.find(s => s.id === up.id);
        if(slot){
          slot.level++;
          slot.maxCharges = Math.max(slot.maxCharges, ABILITY_META[up.id].baseCharges + Math.floor(slot.level / 2));
          slot.charges = clamp(slot.charges + 1, 0, slot.maxCharges);
          slot.cooldownMs = Math.max(2400, ABILITY_META[up.id].baseCooldown - slot.level * 700);
        }
      }
      if(up.id === 'extraAbilityUse'){
        for(const slot of state.abilitySlots){
          if(slot.level > 0){
            slot.maxCharges = Math.min(6, slot.maxCharges + 1);
            slot.charges = slot.maxCharges;
          }
        }
      }
      if(up.id === 'phaseStride'){
        state.phaseWalkUntil = Math.max(state.phaseWalkUntil, state.timeSec + 10);
      }
      if(up.id === 'whip') p.whipLevel++;
      if(up.id === 'garlic') p.garlicLevel++;
      if(up.id === 'stakes') p.stakesLevel++;
      if(up.id === 'bats') p.batsLevel++;
      const fx = up.effectsPerLevel || {};
      if(fx.damage) p.damage += fx.damage;
      if(fx.cooldownMs) p.cooldownMs += fx.cooldownMs;
      if(fx.moveSpeed) p.moveSpeed += fx.moveSpeed;
      if(fx.pickupRadius) p.pickupRadius += fx.pickupRadius;
      if(fx.maxHp){ p.maxHp += fx.maxHp; p.hp += (fx.heal || 0); }
      if(fx.maxShield){ p.maxShield += fx.maxShield; p.shield += fx.maxShield; }
      if(fx.lifeSteal) p.lifeSteal = (p.lifeSteal || 0) + fx.lifeSteal;
      if(fx.critChance) p.critChance = (p.critChance || 0) + fx.critChance;
      if(fx.critMult) p.critMult = (p.critMult || 1.5) + fx.critMult;
      if(fx.armor) p.armor = (p.armor || 0) + fx.armor;
      p.hp = clamp(p.hp,0,p.maxHp);
      p.shield = clamp(p.shield || 0,0,p.maxShield || 0);
    }

    function rebuildFromUpgrades(){
      const hpRatio = state.player.maxHp > 0 ? state.player.hp / state.player.maxHp : 1;
      Object.assign(state.player, {
        maxHp: BASE_PLAYER.maxHp,
        hp: BASE_PLAYER.hp,
        shield: 0,
        maxShield: state.fixtures.armorStand ? 16 : 0,
        lifeSteal: 0,
        critChance: 0,
        critMult: 1.6,
        armor: 0,
        moveSpeed: BASE_PLAYER.moveSpeed,
        damage: BASE_PLAYER.damage,
        pickupRadius: BASE_PLAYER.pickupRadius,
        cooldownMs: BASE_PLAYER.cooldownMs,
        whipLevel: BASE_PLAYER.whipLevel,
        garlicLevel: BASE_PLAYER.garlicLevel,
        stakesLevel: BASE_PLAYER.stakesLevel,
        batsLevel: BASE_PLAYER.batsLevel
      });
      initAbilitySlots();
      for(const [id, lv] of Object.entries(state.upgradeLevels)){
        const up = state.configs.upgrades.find(u => u.id === id);
        if(!up) continue;
        for(let i=0;i<lv;i++) applyUpgrade(up);
        state.upgradeLevels[id] = lv;
      }
      state.player.hp = clamp(state.player.maxHp * hpRatio, 1, state.player.maxHp);
      state.player.shield = state.player.maxShield;
    }

    function applyDeathPenalty(){
      const beforeMoney = state.money;
      state.money = Math.floor(state.money * 0.5);
      const lostMoney = beforeMoney - state.money;
      const pool = Object.entries(state.upgradeLevels).filter(([, lv]) => lv > 0);
      let lostUpgrade = '';
      if(pool.length){
        const [id] = pool[Math.floor(Math.random() * pool.length)];
        const up = state.configs.upgrades.find(u => u.id === id);
        lostUpgrade = up?.name || id;
        state.upgradeLevels[id] = 0;
        rebuildFromUpgrades();
      }
      state.deathNote = lostUpgrade
        ? `You died. Lost $${lostMoney} and ${lostUpgrade}.`
        : `You died. Lost $${lostMoney}.`;
    }

    function activateAbilitySlot(index){
      const slot = state.abilitySlots[index];
      if(!slot || slot.level <= 0 || slot.charges <= 0) return;
      const now = performance.now();
      if(now < slot.nextReadyAt) return;
      const used = useAbility(slot);
      if(!used) return;
      slot.charges--;
      slot.nextReadyAt = now + slot.cooldownMs;
    }

    function useAbility(slot){
      const p = state.player;
      const moveVec = normalize(state.movement.vx || p.aimX, state.movement.vy || p.aimY);
      if(slot.id === 'teleportStep'){
        const range = 2.7 + slot.level * 0.9;
        for(let step=1; step<=10; step++){
          const tx = clamp(p.x + moveVec.x * range * (step / 10), 0, GRID_W - 0.001);
          const ty = clamp(p.y + moveVec.y * range * (step / 10), 0, GRID_H - 0.001);
          if(!circleBlocked(tx, ty, 0.28)){ p.x = tx; p.y = ty; }
        }
        spawnParticles('blast', p.x, p.y, 14 + slot.level * 2);
        return true;
      }
      if(slot.id === 'sentinelClone'){
        state.clones.push({ x: p.x, y: p.y, ttl: 5 + slot.level * 1.5, dps: 8 + slot.level * 4, range: 4 + slot.level * 0.6 });
        return true;
      }
      if(slot.id === 'graveWall'){
        p.wallTrailUntil = state.timeSec + 5;
        p.wallTrailPower = 6 + slot.level * 1.2;
        return true;
      }
      if(slot.id === 'sprintBurst'){
        state.effects.sprintUntil = Math.max(state.effects.sprintUntil, state.timeSec + 6 + slot.level * 0.5);
        return true;
      }
      if(slot.id === 'novaBlast'){
        const radius = 3.6 + slot.level * 0.65;
        const dmg = 18 + slot.level * 11;
        for(const e of state.enemies){ if(dist(p, e) < radius){ e.hp -= dmg; e.hitFlash = 0.2; } }
        spawnParticles('blast', p.x, p.y, 26 + slot.level * 6);
        return true;
      }
      if(slot.id === 'bladeWhirl'){
        state.effects.spinUntil = Math.max(state.effects.spinUntil, state.timeSec + 4 + slot.level * 0.5);
        return true;
      }
      if(slot.id === 'dashRampage'){
        state.effects.rampageUntil = Math.max(state.effects.rampageUntil, state.timeSec + 2.3 + slot.level * 0.45);
        return true;
      }
      if(slot.id === 'glueTrap'){
        state.traps.push({ x: p.x + moveVec.x * 1.1, y: p.y + moveVec.y * 1.1, ttl: 4.4 + slot.level * 0.6, radius: 1.4 + slot.level * 0.2, slow: Math.max(0.2, 0.58 - slot.level * 0.05), dps: 4 + slot.level * 1.8 });
        return true;
      }
      if(slot.id === 'downgradeHex'){
        const radius = 4.2 + slot.level * 0.6;
        for(const e of state.enemies){ if(dist(p, e) < radius) downgradeEnemy(e); }
        return true;
      }
      if(slot.id === 'dualWield'){
        state.effects.dualWieldUntil = Math.max(state.effects.dualWieldUntil, state.timeSec + 7 + slot.level * 0.6);
        return true;
      }
      if(slot.id === 'voidLance'){
        const aim = normalize(p.aimX, p.aimY);
        for(let i=1;i<=3 + Math.floor(slot.level/2);i++){
          state.activeLances.push({ x: p.x + aim.x * i * 1.4, y: p.y + aim.y * i * 1.4, ttl: 2 + slot.level * 0.3, dps: 12 + slot.level * 4 });
        }
        return true;
      }
      if(slot.id === 'meteorCall'){
        const strikes = 3 + Math.floor(slot.level / 2);
        for(let i=0;i<strikes;i++){
          const e = state.enemies[Math.floor(Math.random() * state.enemies.length)];
          if(!e) continue;
          const mx = e.x + rand(-0.7, 0.7), my = e.y + rand(-0.7, 0.7);
          for(const target of state.enemies){ if(Math.hypot(target.x - mx, target.y - my) < 1.4){ target.hp -= 20 + slot.level * 8; target.hitFlash = 0.3; } }
          spawnParticles('blast', mx, my, 15);
        }
        return true;
      }
      if(slot.id === 'timeBubble'){
        state.effects.timeBubbleUntil = Math.max(state.effects.timeBubbleUntil, state.timeSec + 4.5 + slot.level * 0.6);
        return true;
      }
      return false;
    }


    function upgradeSummary(up){
      const parts = [up.description];
      const fx = up.effectsPerLevel || {};
      if(fx.damage) parts.push(`DMG +${fx.damage}`);
      if(fx.cooldownMs) parts.push(`Fire rate ${fx.cooldownMs < 0 ? '+' : '-'}${Math.abs(fx.cooldownMs)}ms`);
      if(fx.moveSpeed) parts.push(`Move +${fx.moveSpeed.toFixed(2)}`);
      if(fx.pickupRadius) parts.push(`Pickup +${fx.pickupRadius.toFixed(2)}`);
      if(fx.maxHp) parts.push(`Max HP +${fx.maxHp}`);
      if(fx.heal) parts.push(`Heal +${fx.heal}`);
      return parts.join(' · ');
    }


    function doorInfo(){
      if(state.room === 'run') return { x: Math.floor(GRID_W / 2), y: GRID_H - 2, target: 'safehouse' };
      return { x: Math.floor(GRID_W / 2), y: 1, target: 'run' };
    }

    function updateDoorState(dt){
      const door = doorInfo();
      const touching = Math.hypot(state.player.x - (door.x + 0.5), state.player.y - (door.y + 0.5)) < 1.1;
      if(touching && state.room === 'safehouse' && state.paused) return;
      if(touching){
        state.doorTouchSec = Math.min(3, state.doorTouchSec + dt);
      } else {
        state.doorTouchSec = Math.max(0, state.doorTouchSec - dt * 1.7);
      }
      if(state.doorTouchSec >= 3){
        state.doorTouchSec = 0;
        if(state.room === 'run'){
          state.highestUnlockedLevel = Math.max(state.highestUnlockedLevel, state.selectedLevelIndex + 1);
          setupSafehouse();
        } else {
          startRun();
        }
      }
    }

    function spawnLogic(){
      if(state.room !== 'run') return;
      const now = performance.now();
      const w = currentWave();
      if(now >= state.nextSpawnAt){
        const roll = Math.random() < 0.025;
        spawnEnemy(roll ? 'juggernaut' : pickWeighted(w.mix));
        state.nextSpawnAt = now + w.spawnEveryMs;
      }
      if(state.timeSec >= state.nextBossAt){
        spawnEnemy('boss');
        state.nextBossAt += state.levelDef.bossIntervalSec;
      }
    }
    function inputLogic(dt){
      const p = state.player;
      const move = state.joysticks.move;
      const m = normalize(move.x, move.y);
      const accel = 27;
      const drag = 0.83;
      const sprintBoost = state.effects.sprintUntil > state.timeSec ? 2.1 : 1;
      const rampageBoost = state.effects.rampageUntil > state.timeSec ? 1.7 : 1;
      state.movement.vx += (m.x * p.moveSpeed * sprintBoost * rampageBoost - state.movement.vx) * Math.min(1, dt * accel);
      state.movement.vy += (m.y * p.moveSpeed * sprintBoost * rampageBoost - state.movement.vy) * Math.min(1, dt * accel);
      if(Math.hypot(move.x, move.y) < 0.1){
        state.movement.vx *= drag;
        state.movement.vy *= drag;
      }
      const nextX = clampInsideBounds(p.x + state.movement.vx * dt, 0.32, GRID_W);
      const nextY = clampInsideBounds(p.y + state.movement.vy * dt, 0.32, GRID_H);
      p.x = nextX;
      p.y = nextY;

      // Keep movement arena free-form: no ability should paint tile-locked walls on the run map.

      const aim = state.joysticks.aim;
      if(aim.active && Math.hypot(aim.x, aim.y) > 0.2){
        p.aimX += (aim.x - p.aimX) * Math.min(1, dt * 20); p.aimY += (aim.y - p.aimY) * Math.min(1, dt * 20);
      } else if(AUTO_AIM_ENABLED && state.enemies.length){
        const nearest = state.enemies.reduce((best,e)=> dist(p,e) < dist(p,best)?e:best, state.enemies[0]);
        p.aimX += (nearest.x - p.x - p.aimX) * Math.min(1, dt * 10); p.aimY += (nearest.y - p.y - p.aimY) * Math.min(1, dt * 10);
      }
      if(state.room === 'run') fire();

      for(const slot of state.abilitySlots){
        if(slot.level > 0 && slot.charges < slot.maxCharges && performance.now() >= slot.nextReadyAt){
          slot.charges++;
          if(slot.charges < slot.maxCharges) slot.nextReadyAt = performance.now() + slot.cooldownMs;
        }
      }
    }

    function render(){
      const glyphs = Array.from({length:GRID_H},()=>Array.from({length:GRID_W},()=> ({ char: ' ', color: '' })));
      const wallChars = ['░','▒','▓','≋','⋇','◈','⟡'];
      for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){
        const hp = state.walls[y]?.[x] || 0;
        if(hp <= 0) continue;
        const hash = Math.abs((x * 73856093) ^ (y * 19349663) ^ ((hp * 13)|0));
        const char = wallChars[hash % wallChars.length];
        const color = hp > 6 ? '#5f78b0' : (hp > 3 ? '#4e6290' : '#3c4d70');
        setCell(glyphs, x, y, char, color);
      }
      for(const g of state.gems){ setCell(glyphs, g.x|0, g.y|0, '$', 'var(--gem)'); }
      for(const pickup of state.pickups){
        const weapon = getWeaponDrop(pickup.weaponId);
        const age = state.timeSec - (pickup.bornAt || 0);
        const blinkAt = pickup.blinkAt || 1.6;
        const blink = age > blinkAt && Math.floor(state.timeSec * 12) % 2 === 0;
        if(blink) continue;
        setCell(glyphs, pickup.x|0, pickup.y|0, weapon.glyph, 'var(--pickup)');
      }
      const p = state.player;

      if(p.garlicLevel>0){
        const r = 1.2 + p.garlicLevel*0.45;
        for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){
          const d = Math.hypot(x-p.x,y-p.y);
          if(d>r-0.4 && d<r+0.4 && glyphs[y][x].char===' ') glyphs[y][x]={char:'~',color:'var(--aura)'};
        }
      }

      if(p.batsLevel>0){
        const count = p.batsLevel + 1;
        for(let i=0;i<count;i++){
          const a = state.timeSec*2.2 + (Math.PI*2/count)*i;
          const r = 1.8 + p.batsLevel*0.25;
          const bx = p.x + Math.cos(a) * r;
          const by = p.y + Math.sin(a) * r;
          setCell(glyphs, bx|0, by|0, 'o', 'var(--bat)');
        }
      }

      for(const b of state.bullets){ setCell(glyphs, Math.floor(b.x), Math.floor(b.y), b.char, 'var(--bullet)'); }
      for(const e of state.enemies){
        const ex = Math.floor(e.x), ey = Math.floor(e.y);
        setCell(glyphs, ex, ey, e.char, e.hitFlash > 0 ? '#ffffff' : (e.color || 'var(--enemy)'));
        if(e.type === 'juggernaut' && e.dashWindup > 0){
          setCell(glyphs, Math.floor(e.x + e.dashDirX * 1.8), Math.floor(e.y + e.dashDirY * 1.8), directionGlyph(e.dashDirX, e.dashDirY), '#ffffff');
        }
      }
      for(const c of state.clones) setCell(glyphs, Math.floor(c.x), Math.floor(c.y), '&', '#c1ccff');
      for(const t of state.traps) setCell(glyphs, Math.floor(t.x), Math.floor(t.y), '¤', '#98f59f');
      for(const l of state.activeLances) setCell(glyphs, Math.floor(l.x), Math.floor(l.y), '|', '#8be8ff');
      for(const f of state.fx) setCell(glyphs, Math.floor(f.x), Math.floor(f.y), f.char, f.color);
      const door = doorInfo();
      setCell(glyphs, door.x, door.y, 'D', state.doorTouchSec > 0 ? '#9fffad' : '#d9f0ff');
      const playerChar = state.effects.spinUntil > state.timeSec ? '✶' : '@';
      setCell(glyphs, Math.floor(p.x), Math.floor(p.y), playerChar, 'var(--player)');

      const lines = glyphs.map(row => row.map(cell => cell.color
        ? `<span class="glyph" style="color:${cell.color}">${escapeHtml(cell.char)}</span>`
        : escapeHtml(cell.char)).join(''));
      screen.innerHTML = lines.join('\n');

      const selected = state.abilitySlots[state.selectedAbilityIndex] || state.abilitySlots[0];
      if(selected){
        if(selected.level <= 0){
          abilitySlotBtn.className = 'hotkey-slot empty';
          abilitySlotBtn.innerHTML = `${ABILITY_META[selected.id].name}<br>Locked<br>${ABILITY_META[selected.id].desc}`;
        } else {
          const ready = performance.now() >= selected.nextReadyAt;
          const remains = ready ? 'Ready' : `${((selected.nextReadyAt - performance.now()) / 1000).toFixed(1)}s`;
          abilitySlotBtn.className = `hotkey-slot ${ready ? 'ready' : 'cooling'}`;
          abilitySlotBtn.innerHTML = `${ABILITY_META[selected.id].name}<br>Lv ${selected.level} · ${selected.charges}/${selected.maxCharges}<br>${remains}`;
        }
      }


      shieldFill.style.width = `${(p.shield/Math.max(1,p.maxShield))*100}%`;
      hpFill.style.width = `${(p.hp/p.maxHp)*100}%`;
      xpFill.style.width = `${(state.doorTouchSec/3)*100}%`;
      const shapeTag = state.levelDef?.wallPattern === 'shape' && state.shapeName ? ` · ${state.shapeName}` : '';
      const roomTag = state.room === 'run' ? `${state.levelDef?.name || ''}${shapeTag}` : `Safehouse · Target ${state.configs.levels[state.selectedLevelIndex]?.name || ''}`;
      stats.textContent = `$${state.money} · ${fmtTime(state.timeSec)} · ${roomTag} · ${getWeaponDrop(state.activeWeapon).name} · KOs ${state.kills}`;
      const inSafehouse = state.room === 'safehouse';
      safehouseControls.style.display = inSafehouse ? 'flex' : 'none';
      shopBtn.textContent = state.shopOpen ? 'Crate Shop ◀' : 'Crate Shop ▶';
      playLayout.classList.toggle('shop-open', inSafehouse && state.shopOpen);
      shopPanel.style.display = inSafehouse && state.shopOpen ? 'block' : 'none';
      deathNote.textContent = state.deathNote;
    }

    let last = performance.now();
    function loop(){
      requestAnimationFrame(loop);
      const now = performance.now();
      const dt = Math.min(0.05, (now-last)/1000);
      last = now;
      if(state.paused) return;
      state.timeSec += dt;
      inputLogic(dt);
      if(state.room === 'run'){
        spawnLogic();
        whipTick(dt);
        garlicTick(dt);
        batsTick(dt);
        cloneLogic(dt);
        abilityEffectsLogic(dt);
        bulletLogic(dt);
        enemyLogic(dt);
        fxLogic(dt);
        pickupGems();
      }
      updateDoorState(dt);
      render();

      if(state.player.hp <= 0 && state.room === 'run'){
        applyDeathPenalty();
        state.player.hp = state.player.maxHp;
        setupSafehouse();
      }
    }

    boot().catch(err => {
      screen.textContent = 'Failed to load JSON files. Serve files over HTTP (not file://).\n' + err.message;
    });
  </script>
</body>
</html>
